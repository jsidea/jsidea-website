{
  "project": {
    "name": "jsidea",
    "url": "https://raw.githubusercontent.com/jsidea/jsidea/01d2868f284976e28e1a6382555fbf3f0e6ee3fa/"
  },
  "typescript": [
    {
      "fullName": "jsidea.action.Cursor",
      "file": "src/jsidea/action/Cursor.ts",
      "kind": 212,
      "imports": [
        "jsidea.action.Cursor",
        "jsidea.events.EventDispatcher",
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.action.Drag",
      "file": "src/jsidea/action/Drag.ts",
      "kind": 212,
      "imports": [
        "jsidea.action.Drag",
        "jsidea.events.EventDispatcher",
        "jsidea.geom.Point3D",
        "jsidea.geom.Rect2D",
        "jsidea.layout.Transform",
        "jsidea.layout.Box",
        "jsidea.layout.Position",
        "jsidea.layout.Move",
        "jsidea.layout.MoveMode.TRANSFORM",
        "jsidea.layout.IMoveMode",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.IPositionTo"
      ]
    },
    {
      "fullName": "jsidea.action.EventCircuit",
      "file": "src/jsidea/action/EventCircuit.ts",
      "kind": 212,
      "imports": [
        "jsidea.action.EventCircuit",
        "jsidea.events.EventDispatcher",
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.build.Builder",
      "file": "src/jsidea/build/Builder.ts",
      "kind": 212,
      "imports": [
        "jsidea.build.Builder"
      ]
    },
    {
      "fullName": "jsidea.build.CompilerHost",
      "file": "src/jsidea/build/CompilerHost.ts",
      "kind": 212,
      "imports": [
        "jsidea.build.CompilerHost",
        "jsidea.build.FileSystem",
        "jsidea.build.IFile"
      ]
    },
    {
      "fullName": "jsidea.build.FileSystem",
      "file": "src/jsidea/build/FileSystem.ts",
      "kind": 212,
      "imports": [
        "jsidea.build.FileSystem",
        "jsidea.build.IFileSystem",
        "jsidea.build.IFile"
      ]
    },
    {
      "fullName": "jsidea.build.IFile",
      "file": "src/jsidea/build/IFile.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IFile"
      ]
    },
    {
      "fullName": "jsidea.build.IFileSystem",
      "file": "src/jsidea/build/IFileSystem.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IFileSystem",
        "jsidea.build.IFile"
      ]
    },
    {
      "fullName": "jsidea.build.IMinify",
      "file": "src/jsidea/build/IMinify.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IMinify",
        "jsidea.build.IFile",
        "jsidea.build.IMinifyResult"
      ]
    },
    {
      "fullName": "jsidea.build.IMinifyResult",
      "file": "src/jsidea/build/IMinifyResult.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IMinifyResult"
      ]
    },
    {
      "fullName": "jsidea.build.ISymbol",
      "file": "src/jsidea/build/ISymbol.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.ISymbol",
        "jsidea.build.IFile"
      ]
    },
    {
      "fullName": "jsidea.build.IUsage",
      "file": "src/jsidea/build/IUsage.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IUsage",
        "jsidea.build.IFile",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.build.IUsageResult",
      "file": "src/jsidea/build/IUsageResult.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.IUsageResult",
        "jsidea.build.ISymbol"
      ]
    },
    {
      "fullName": "jsidea.build.Minify.IJavaScriptOptions",
      "file": "src/jsidea/build/Minify/JavaScript.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.Minify.IJavaScriptOptions",
        "jsidea.build.IFile",
        "jsidea.build.IMinifyResult",
        "jsidea.build.Minify.JAVASCRIPT"
      ]
    },
    {
      "fullName": "jsidea.build.Minify.JAVASCRIPT",
      "file": "src/jsidea/build/Minify/JavaScript.ts",
      "kind": 209,
      "imports": [
        "jsidea.build.Minify.IJavaScriptOptions",
        "jsidea.build.IFile",
        "jsidea.build.IMinifyResult",
        "jsidea.build.Minify.JAVASCRIPT"
      ]
    },
    {
      "fullName": "jsidea.build.Usage.ITypeScriptOptions",
      "file": "src/jsidea/build/Usage/TypeScript.ts",
      "kind": 213,
      "imports": [
        "jsidea.build.Usage.ITypeScriptOptions",
        "jsidea.build.IUsage",
        "jsidea.build.ISymbol",
        "jsidea.build.IFile",
        "jsidea.build.IUsageResult",
        "jsidea.build.CompilerHost",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT"
      ]
    },
    {
      "fullName": "jsidea.build.Usage.TYPESCRIPT",
      "file": "src/jsidea/build/Usage/TypeScript.ts",
      "kind": 209,
      "imports": [
        "jsidea.build.Usage.ITypeScriptOptions",
        "jsidea.build.IUsage",
        "jsidea.build.ISymbol",
        "jsidea.build.IFile",
        "jsidea.build.IUsageResult",
        "jsidea.build.CompilerHost",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT"
      ]
    },
    {
      "fullName": "jsidea.display.Graphics",
      "file": "src/jsidea/display/Graphics.ts",
      "kind": 212,
      "imports": [
        "jsidea.display.Graphics",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.Transform",
        "jsidea.geom.Rect2D",
        "jsidea.layout.Box",
        "jsidea.layout.BoxModel.CANVAS",
        "jsidea.geom.Quad",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.events.EventDispatcher",
      "file": "src/jsidea/events/EventDispatcher.ts",
      "kind": 212,
      "imports": [
        "jsidea.events.EventDispatcher",
        "jsidea.events.IEventDispatcher",
        "jsidea.model.Dictonary",
        "jsidea.events.IEventListener"
      ]
    },
    {
      "fullName": "jsidea.events.Events",
      "file": "src/jsidea/events/Events.ts",
      "kind": 212,
      "imports": [
        "jsidea.events.Events"
      ]
    },
    {
      "fullName": "jsidea.events.IEventDispatcher",
      "file": "src/jsidea/events/IEventDispatcher.ts",
      "kind": 213,
      "imports": [
        "jsidea.events.IEventDispatcher"
      ]
    },
    {
      "fullName": "jsidea.events.IEventListener",
      "file": "src/jsidea/events/IEventListener.ts",
      "kind": 213,
      "imports": [
        "jsidea.events.IEventListener"
      ]
    },
    {
      "fullName": "jsidea.geom.IComposition2D",
      "file": "src/jsidea/geom/IComposition2D.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IComposition2D",
        "jsidea.geom.Point2D"
      ]
    },
    {
      "fullName": "jsidea.geom.IComposition3D",
      "file": "src/jsidea/geom/IComposition3D.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IComposition3D",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.geom.IMatrix2DValue",
      "file": "src/jsidea/geom/IMatrix2DValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IMatrix2DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.IMatrix3DValue",
      "file": "src/jsidea/geom/IMatrix3DValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IMatrix3DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.IPoint2DValue",
      "file": "src/jsidea/geom/IPoint2DValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.IPoint3DValue",
      "file": "src/jsidea/geom/IPoint3DValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IPoint3DValue",
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.IQuadValue",
      "file": "src/jsidea/geom/IQuadValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IQuadValue",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.geom.IRect2DValue",
      "file": "src/jsidea/geom/IRect2DValue.ts",
      "kind": 213,
      "imports": [
        "jsidea.geom.IRect2DValue",
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.Matrix2D",
      "file": "src/jsidea/geom/Matrix2D.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Matrix2D",
        "jsidea.geom.IMatrix2DValue",
        "jsidea.geom.IPoint2DValue",
        "jsidea.geom.Point2D",
        "jsidea.math.Number",
        "jsidea.geom.IComposition2D"
      ]
    },
    {
      "fullName": "jsidea.geom.Matrix3D",
      "file": "src/jsidea/geom/Matrix3D.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Matrix3D",
        "jsidea.geom.IMatrix3DValue",
        "jsidea.geom.IPoint2DValue",
        "jsidea.geom.Point3D",
        "jsidea.geom.IPoint3DValue",
        "jsidea.math.Number",
        "jsidea.geom.IComposition3D",
        "jsidea.geom.Rect2D"
      ]
    },
    {
      "fullName": "jsidea.geom.MatrixFit",
      "file": "src/jsidea/geom/MatrixFit.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.MatrixFit",
        "jsidea.geom.IQuadValue",
        "jsidea.geom.Matrix2D",
        "jsidea.geom.IPoint2DValue",
        "jsidea.geom.Quad",
        "jsidea.geom.Point3D",
        "jsidea.geom.Point2D",
        "jsidea.geom.IPoint3DValue",
        "jsidea.geom.Matrix3D"
      ]
    },
    {
      "fullName": "jsidea.geom.MatrixUtil",
      "file": "src/jsidea/geom/MatrixUtil.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.MatrixUtil",
        "jsidea.geom.Point3D",
        "jsidea.geom.Matrix3D"
      ]
    },
    {
      "fullName": "jsidea.geom.Point2D",
      "file": "src/jsidea/geom/Point2D.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Point2D",
        "jsidea.geom.IPoint2DValue",
        "jsidea.math.Number"
      ]
    },
    {
      "fullName": "jsidea.geom.Point3D",
      "file": "src/jsidea/geom/Point3D.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Point3D",
        "jsidea.geom.IPoint3DValue",
        "jsidea.geom.IPoint2DValue",
        "jsidea.math.Number"
      ]
    },
    {
      "fullName": "jsidea.geom.Quad",
      "file": "src/jsidea/geom/Quad.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Quad",
        "jsidea.geom.IQuadValue",
        "jsidea.geom.Point3D",
        "jsidea.geom.IPoint3DValue"
      ]
    },
    {
      "fullName": "jsidea.geom.Rect2D",
      "file": "src/jsidea/geom/Rect2D.ts",
      "kind": 212,
      "imports": [
        "jsidea.geom.Rect2D",
        "jsidea.geom.IRect2DValue",
        "jsidea.geom.Quad",
        "jsidea.geom.Point3D",
        "jsidea.system.Engine",
        "jsidea.math.Number",
        "jsidea.geom.IPoint2DValue",
        "jsidea.geom.Point2D"
      ]
    },
    {
      "fullName": "jsidea.layout.Box",
      "file": "src/jsidea/layout/Box.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.Box",
        "jsidea.system.Engine",
        "jsidea.math.Number",
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Rect2D",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.ATTACHMENT",
      "file": "src/jsidea/layout/BoxModel/Attachment.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.BoxModel.Background",
        "jsidea.layout.Box",
        "jsidea.geom.Rect2D",
        "jsidea.system.Engine",
        "jsidea.layout.Transform",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.ATTACHMENT",
        "jsidea.layout.IBoxModel"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.Background",
      "file": "src/jsidea/layout/BoxModel/Background.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.BoxModel.Background",
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Point3D",
        "jsidea.layout.Box",
        "jsidea.geom.Rect2D",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.math.Number",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.BoxModel.BACKGROUND"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.BACKGROUND",
      "file": "src/jsidea/layout/BoxModel/Background.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.BoxModel.Background",
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Point3D",
        "jsidea.layout.Box",
        "jsidea.geom.Rect2D",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.math.Number",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.BoxModel.BACKGROUND"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.BORDER",
      "file": "src/jsidea/layout/BoxModel/Border.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.BORDER"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.CANVAS",
      "file": "src/jsidea/layout/BoxModel/Canvas.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Matrix2D",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.geom.Point2D",
        "jsidea.layout.BoxModel.CANVAS"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.CLIP",
      "file": "src/jsidea/layout/BoxModel/Clip.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Rect2D",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.CLIP"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.CONTENT",
      "file": "src/jsidea/layout/BoxModel/Content.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.CONTENT"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.IMAGE",
      "file": "src/jsidea/layout/BoxModel/Image.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.IMAGE"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.MARGIN",
      "file": "src/jsidea/layout/BoxModel/Margin.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.MARGIN"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.NDC",
      "file": "src/jsidea/layout/BoxModel/NormalDeviceCoordinates.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.NDC"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.PADDING",
      "file": "src/jsidea/layout/BoxModel/Padding.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.PADDING"
      ]
    },
    {
      "fullName": "jsidea.layout.BoxModel.SCROLL",
      "file": "src/jsidea/layout/BoxModel/Scroll.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point2D",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.layout.BoxModel.SCROLL"
      ]
    },
    {
      "fullName": "jsidea.layout.IBoxModel",
      "file": "src/jsidea/layout/IBoxModel.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IBoxModel",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.layout.IMoveLimits",
      "file": "src/jsidea/layout/IMoveLimits.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IMoveLimits",
        "jsidea.layout.IBoxModel"
      ]
    },
    {
      "fullName": "jsidea.layout.IMoveMode",
      "file": "src/jsidea/layout/IMoveMode.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.layout.IPositionFrom",
      "file": "src/jsidea/layout/IPositionFrom.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IPositionFrom",
        "jsidea.layout.IPositionTo",
        "jsidea.math.ILimit"
      ]
    },
    {
      "fullName": "jsidea.layout.IPositionTo",
      "file": "src/jsidea/layout/IPositionTo.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IPositionTo",
        "jsidea.layout.IBoxModel"
      ]
    },
    {
      "fullName": "jsidea.layout.ISnapGrid",
      "file": "src/jsidea/layout/ISnapGrid.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.ISnapGrid",
        "jsidea.layout.IBoxModel"
      ]
    },
    {
      "fullName": "jsidea.layout.ISnapMode",
      "file": "src/jsidea/layout/ISnapMode.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.ISnapMode",
        "jsidea.layout.Snap",
        "jsidea.layout.Transform",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.layout.ISnapTo",
      "file": "src/jsidea/layout/ISnapTo.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.ISnapTo",
        "jsidea.layout.IBoxModel"
      ]
    },
    {
      "fullName": "jsidea.layout.IStyleNode",
      "file": "src/jsidea/layout/IStyleNode.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.IStyleNode",
        "jsidea.geom.Point2D"
      ]
    },
    {
      "fullName": "jsidea.layout.ITransformMode",
      "file": "src/jsidea/layout/ITransformMode.ts",
      "kind": 213,
      "imports": [
        "jsidea.layout.ITransformMode",
        "jsidea.layout.Transform",
        "jsidea.geom.Matrix3D"
      ]
    },
    {
      "fullName": "jsidea.layout.Move",
      "file": "src/jsidea/layout/Move.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.Move",
        "jsidea.geom.Point3D",
        "jsidea.layout.IMoveLimits",
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Transform",
        "jsidea.layout.MoveMode.TRANSFORM",
        "jsidea.layout.Box",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.math.Number",
        "jsidea.geom.Rect2D"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BACKGROUND",
      "file": "src/jsidea/layout/MoveMode/Background.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.BACKGROUND",
        "jsidea.geom.Rect2D",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.layout.MoveMode.BACKGROUND"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BORDER_BOTTOM_RIGHT_INNER",
      "file": "src/jsidea/layout/MoveMode/BorderBottomRightInner.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.BORDER_BOTTOM_RIGHT_INNER"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BORDER_BOTTOM_RIGHT_OUTER",
      "file": "src/jsidea/layout/MoveMode/BorderBottomRightOuter.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.BORDER_BOTTOM_RIGHT_OUTER"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BORDER_TOP_LEFT",
      "file": "src/jsidea/layout/MoveMode/BorderTopLeft.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.BORDER_TOP_LEFT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BOTTOM_LEFT",
      "file": "src/jsidea/layout/MoveMode/BottomLeft.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.BOTTOM_RIGHT",
        "jsidea.layout.MoveMode.TOP_LEFT",
        "jsidea.layout.MoveMode.BOTTOM_LEFT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.BOTTOM_RIGHT",
      "file": "src/jsidea/layout/MoveMode/BottomRight.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.TOP_LEFT",
        "jsidea.layout.StyleNode",
        "jsidea.layout.IStyleNode",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.BOTTOM_RIGHT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.CLIP",
      "file": "src/jsidea/layout/MoveMode/Clip.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.CLIP",
        "jsidea.geom.Rect2D",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.CLIP"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.CLIP_BOTTOM_RIGHT",
      "file": "src/jsidea/layout/MoveMode/ClipBottomRight.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.CLIP",
        "jsidea.geom.Rect2D",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.CLIP_BOTTOM_RIGHT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.MARGIN_BOTTOM_RIGHT",
      "file": "src/jsidea/layout/MoveMode/MarginBottomRight.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Point3D",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.MARGIN_BOTTOM_RIGHT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.MARGIN_TOP_LEFT",
      "file": "src/jsidea/layout/MoveMode/MarginTopLeft.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Point3D",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.MARGIN_TOP_LEFT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.SCROLL",
      "file": "src/jsidea/layout/MoveMode/Scroll.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.SCROLL",
        "jsidea.geom.Point3D",
        "jsidea.system.Engine",
        "jsidea.layout.MoveMode.SCROLL"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.TOP_LEFT",
      "file": "src/jsidea/layout/MoveMode/TopLeft.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Box",
        "jsidea.geom.Point3D",
        "jsidea.system.Engine",
        "jsidea.layout.StyleNode",
        "jsidea.layout.IStyleNode",
        "jsidea.geom.Point2D",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.BoxModel.CONTENT",
        "jsidea.system.Browser",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.TOP_LEFT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.TOP_LEFT_CLAMPED",
      "file": "src/jsidea/layout/MoveMode/TopLeftClamped.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.TOP_LEFT",
        "jsidea.math.Number",
        "jsidea.layout.MoveMode.TOP_LEFT_CLAMPED"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.TOP_RIGHT",
      "file": "src/jsidea/layout/MoveMode/TopRight.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.TOP_LEFT",
        "jsidea.layout.MoveMode.BOTTOM_RIGHT",
        "jsidea.layout.MoveMode.TOP_RIGHT"
      ]
    },
    {
      "fullName": "jsidea.layout.MoveMode.TRANSFORM",
      "file": "src/jsidea/layout/MoveMode/Transform.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.IMoveMode",
        "jsidea.geom.Matrix3D",
        "jsidea.geom.Point3D",
        "jsidea.system.Engine",
        "jsidea.layout.MoveMode.TRANSFORM"
      ]
    },
    {
      "fullName": "jsidea.layout.Position",
      "file": "src/jsidea/layout/Position.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.Position",
        "jsidea.layout.IPositionTo",
        "jsidea.layout.IPositionFrom",
        "jsidea.layout.Snap",
        "jsidea.layout.Move",
        "jsidea.layout.Transform",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.Box",
        "jsidea.math.Number",
        "jsidea.geom.Rect2D",
        "jsidea.math.ILimit",
        "jsidea.geom.Matrix3D"
      ]
    },
    {
      "fullName": "jsidea.layout.Snap",
      "file": "src/jsidea/layout/Snap.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.Snap",
        "jsidea.layout.ISnapMode",
        "jsidea.layout.ISnapTo",
        "jsidea.layout.ISnapGrid",
        "jsidea.layout.Move",
        "jsidea.layout.Transform",
        "jsidea.geom.Point3D",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.layout.SnapMode.BASIC",
        "jsidea.layout.Box",
        "jsidea.math.Number",
        "jsidea.geom.Rect2D",
        "jsidea.geom.Matrix3D"
      ]
    },
    {
      "fullName": "jsidea.layout.SnapMode.BASIC",
      "file": "src/jsidea/layout/SnapMode/Basic.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.ISnapMode",
        "jsidea.layout.Snap",
        "jsidea.layout.Transform",
        "jsidea.geom.Point3D",
        "jsidea.math.Number",
        "jsidea.layout.SnapMode.BASIC"
      ]
    },
    {
      "fullName": "jsidea.layout.StyleNode",
      "file": "src/jsidea/layout/StyleNode.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.StyleNode",
        "jsidea.layout.IStyleNode",
        "jsidea.system.Browser",
        "jsidea.system.Engine",
        "jsidea.math.Number",
        "jsidea.geom.Point2D"
      ]
    },
    {
      "fullName": "jsidea.layout.Transform",
      "file": "src/jsidea/layout/Transform.ts",
      "kind": 212,
      "imports": [
        "jsidea.layout.Transform",
        "jsidea.layout.IBoxModel",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.geom.Matrix3D",
        "jsidea.layout.Box",
        "jsidea.layout.ITransformMode",
        "jsidea.layout.TransformMode.RECTANGLE",
        "jsidea.layout.TransformMode.PERSPECTIVE",
        "jsidea.geom.Point3D",
        "jsidea.geom.Quad"
      ]
    },
    {
      "fullName": "jsidea.layout.TransformMode.PERSPECTIVE",
      "file": "src/jsidea/layout/TransformMode/Perspective.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.ITransformMode",
        "jsidea.geom.Matrix3D",
        "jsidea.layout.Transform",
        "jsidea.layout.StyleNode",
        "jsidea.layout.IStyleNode",
        "jsidea.math.Number",
        "jsidea.geom.Point2D",
        "jsidea.layout.TransformMode.PERSPECTIVE"
      ]
    },
    {
      "fullName": "jsidea.layout.TransformMode.PLANAR",
      "file": "src/jsidea/layout/TransformMode/Planar.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.ITransformMode",
        "jsidea.layout.Transform",
        "jsidea.geom.Matrix3D",
        "jsidea.geom.Rect2D",
        "jsidea.system.Browser",
        "jsidea.math.Number",
        "jsidea.system.Engine",
        "jsidea.layout.TransformMode.PLANAR"
      ]
    },
    {
      "fullName": "jsidea.layout.TransformMode.RECTANGLE",
      "file": "src/jsidea/layout/TransformMode/Rectangle.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.ITransformMode",
        "jsidea.layout.Transform",
        "jsidea.geom.Matrix3D",
        "jsidea.geom.Rect2D",
        "jsidea.layout.TransformMode.RECTANGLE"
      ]
    },
    {
      "fullName": "jsidea.layout.TransformMode.TEST",
      "file": "src/jsidea/layout/TransformMode/Test.ts",
      "kind": 209,
      "imports": [
        "jsidea.layout.ITransformMode",
        "jsidea.layout.Transform",
        "jsidea.geom.Matrix3D",
        "jsidea.geom.Rect2D",
        "jsidea.layout.TransformMode.TEST"
      ]
    },
    {
      "fullName": "jsidea.math.ILimit",
      "file": "src/jsidea/math/ILimit.ts",
      "kind": 213,
      "imports": [
        "jsidea.math.ILimit"
      ]
    },
    {
      "fullName": "jsidea.math.Number",
      "file": "src/jsidea/math/Number.ts",
      "kind": 212,
      "imports": [
        "jsidea.math.Number",
        "jsidea.geom.IPoint3DValue",
        "jsidea.math.ILimit",
        "jsidea.geom.IPoint2DValue"
      ]
    },
    {
      "fullName": "jsidea.model.Converter.Json",
      "file": "src/jsidea/model/Converter/Json.ts",
      "kind": 209,
      "imports": [
        "jsidea.model.IConverter",
        "jsidea.model.Converter.Json"
      ]
    },
    {
      "fullName": "jsidea.model.Dictonary",
      "file": "src/jsidea/model/Dictionary.ts",
      "kind": 212,
      "imports": [
        "jsidea.model.Dictonary"
      ]
    },
    {
      "fullName": "jsidea.model.IConverter",
      "file": "src/jsidea/model/IConverter.ts",
      "kind": 213,
      "imports": [
        "jsidea.model.IConverter"
      ]
    },
    {
      "fullName": "jsidea.model.LoaderMethod",
      "file": "src/jsidea/model/Loader.ts",
      "kind": 215,
      "imports": [
        "jsidea.model.LoaderMethod",
        "jsidea.model.Loader",
        "jsidea.events.EventDispatcher",
        "jsidea.model.URLRequest"
      ]
    },
    {
      "fullName": "jsidea.model.Loader",
      "file": "src/jsidea/model/Loader.ts",
      "kind": 212,
      "imports": [
        "jsidea.model.LoaderMethod",
        "jsidea.model.Loader",
        "jsidea.events.EventDispatcher",
        "jsidea.model.URLRequest"
      ]
    },
    {
      "fullName": "jsidea.model.URLMethod",
      "file": "src/jsidea/model/URLRequest.ts",
      "kind": 215,
      "imports": [
        "jsidea.model.URLMethod",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.model.IConverter",
        "jsidea.model.Converter.Json"
      ]
    },
    {
      "fullName": "jsidea.model.URLRequest",
      "file": "src/jsidea/model/URLRequest.ts",
      "kind": 212,
      "imports": [
        "jsidea.model.URLMethod",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.model.IConverter",
        "jsidea.model.Converter.Json"
      ]
    },
    {
      "fullName": "jsidea.plugins.IFile",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 213,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.IData",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 213,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.IReferenceData",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 213,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.ISymbol",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 213,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.IModule",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 213,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.ModuleUI",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.SymbolUI",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.Builder",
      "file": "src/jsidea/plugins/Builder.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.IFile",
        "jsidea.plugins.IData",
        "jsidea.plugins.ISymbol",
        "jsidea.plugins.IReferenceData",
        "jsidea.plugins.SymbolUI",
        "jsidea.plugins.IModule",
        "jsidea.plugins.ModuleUI",
        "jsidea.plugins.Builder",
        "jsidea.plugins.Plugin",
        "jsidea.model.URLRequest",
        "jsidea.events.EventDispatcher",
        "jsidea.action.Drag",
        "jsidea.build.FileSystem",
        "jsidea.build.Usage.TYPESCRIPT",
        "jsidea.build.IUsageResult"
      ]
    },
    {
      "fullName": "jsidea.plugins.Plugin",
      "file": "src/jsidea/plugins/Plugin.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.Plugin",
        "jsidea.events.EventDispatcher"
      ]
    },
    {
      "fullName": "jsidea.plugins.Runner",
      "file": "src/jsidea/plugins/Runner.ts",
      "kind": 211,
      "imports": [
        "jsidea.plugins.Runner"
      ]
    },
    {
      "fullName": "jsidea.plugins.Simbox",
      "file": "src/jsidea/plugins/Simbox.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.Simbox",
        "jsidea.plugins.Plugin",
        "jsidea.geom.Matrix3D",
        "jsidea.geom.Point3D"
      ]
    },
    {
      "fullName": "jsidea.plugins.Test",
      "file": "src/jsidea/plugins/Test.ts",
      "kind": 212,
      "imports": [
        "jsidea.plugins.Test",
        "jsidea.plugins.Plugin",
        "jsidea.layout.Transform",
        "jsidea.layout.BoxModel.BORDER",
        "jsidea.geom.Point3D",
        "jsidea.layout.MoveMode.TRANSFORM",
        "jsidea.layout.Snap",
        "jsidea.layout.ISnapGrid",
        "jsidea.layout.BoxModel.PADDING",
        "jsidea.layout.ISnapTo",
        "jsidea.layout.IMoveMode",
        "jsidea.layout.Position",
        "jsidea.layout.Move",
        "jsidea.layout.IPositionTo",
        "jsidea.geom.Rect2D",
        "jsidea.layout.Box",
        "jsidea.display.Graphics",
        "jsidea.geom.Quad",
        "jsidea.geom.Point2D",
        "jsidea.geom.MatrixFit",
        "jsidea.geom.Matrix2D",
        "jsidea.layout.StyleNode",
        "jsidea.layout.IStyleNode",
        "jsidea.text.Text",
        "jsidea.events.EventDispatcher"
      ]
    },
    {
      "fullName": "jsidea.system.Browser",
      "file": "src/jsidea/system/Browser.ts",
      "kind": 212,
      "imports": [
        "jsidea.system.Browser"
      ]
    },
    {
      "fullName": "jsidea.system.Engine",
      "file": "src/jsidea/system/Engine.ts",
      "kind": 212,
      "imports": [
        "jsidea.system.Engine",
        "jsidea.system.Browser"
      ]
    },
    {
      "fullName": "jsidea.system.System",
      "file": "src/jsidea/system/System.ts",
      "kind": 212,
      "imports": [
        "jsidea.system.System"
      ]
    },
    {
      "fullName": "jsidea.text.Text",
      "file": "src/jsidea/text/Text.ts",
      "kind": 212,
      "imports": [
        "jsidea.text.Text",
        "jsidea.math.Number"
      ]
    }
  ],
  "files": [
    {
      "name": "src/definitions/jsidea.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "interface HTMLElement {\r\n    matches(selector: string): boolean;\r\n}\r\n\r\ninterface Object {\r\n    observe(beingObserved: any, callback: (update: any) => any, types?: string[]): void;\r\n}\r\n\r\ninterface CSSStyleDeclaration {\r\n    willChange: string;\r\n}\r\n\r\ninterface MSStyleCSSProperties {\r\n    willChange: string;\r\n}\r\n\r\ninterface CanvasRenderingContext2D {\r\n    getTransform(): number[];\r\n}\r\n\r\ninterface HTMLCanvasElement {\r\n    hasContext(): string;\r\n}"
    },
    {
      "name": "src/jsidea/action/Cursor.ts",
      "size": 826,
      "sizeMinified": 442,
      "code": "namespace jsidea.action {\r\n    export class Cursor extends jsidea.events.EventDispatcher implements geom.IPoint2DValue {\r\n\r\n        public uid: number = 0;\r\n        public x: number = 0;\r\n        public y: number = 0;\r\n        public target: HTMLElement = null;\r\n\r\n        constructor() {\r\n            super();\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/action/Drag.ts",
      "size": 3732,
      "sizeMinified": 2190,
      "code": "namespace jsidea.action {\r\n    export class Drag extends jsidea.events.EventDispatcher {\r\n\r\n        public filter: string = \".symbol\";\r\n        private target: HTMLElement = null;\r\n        private pivot = new geom.Point3D();\r\n        private box = new geom.Rect2D();\r\n        private transform = layout.Transform.create();\r\n        private size: layout.Box = layout.Box.create();\r\n        private cursor = new geom.Point3D();\r\n        private pos = new layout.Position();\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            document.addEventListener(\"mousedown\", (evt) => this.onMouseDown(evt));\r\n            document.addEventListener(\"mousemove\", (evt) => this.onMouseMove(evt));\r\n            document.addEventListener(\"mouseup\", (evt) => this.onMouseUp(evt));\r\n        }\r\n\r\n        private onMouseDown(evt: MouseEvent): void {\r\n            var target = <HTMLElement>evt.target;\r\n            if(this.filter && !target.matches(this.filter))\r\n                return;\r\n            this.target = target;\r\n            \r\n            evt.preventDefault();\r\n            evt.stopImmediatePropagation();\r\n\r\n            var mode = this.pos.move.mode || layout.MoveMode.TRANSFORM;\r\n            target.style.willChange = mode.willChange;\r\n\r\n            this.cursor.setTo(evt.pageX, evt.pageY, 0);\r\n            this.transform.update(target);\r\n\r\n            var mode = this.pos.move.mode || layout.MoveMode.TRANSFORM;\r\n\r\n            var loc = this.transform.globalToLocalPoint(this.cursor, layout.BoxModel.BORDER, this.pos.to.boxModel);\r\n            this.box = this.transform.size.bounds(this.pos.to.boxModel, null, this.box);\r\n            this.pivot.x = mode.invertX ? (this.box.width - loc.x) : loc.x;\r\n            this.pivot.y = mode.invertY ? (this.box.height - loc.y) : loc.y;\r\n\r\n        }\r\n\r\n        private onMouseMove(evt: MouseEvent): void {\r\n            if (!this.target)\r\n                return;\r\n\r\n            evt.preventDefault();\r\n            evt.stopImmediatePropagation();\r\n\r\n            var mode = this.pos.move.mode || layout.MoveMode.TRANSFORM;\r\n\r\n            this.cursor.setTo(evt.pageX, evt.pageY, 0);\r\n            this.size.update(this.target, window.getComputedStyle(this.target));\r\n            this.box = this.size.bounds(this.pos.to.boxModel, null, this.box);\r\n            this.pos.to.x = mode.invertX ? (this.box.width - this.pivot.x) : this.pivot.x;\r\n            this.pos.to.y = mode.invertY ? (this.box.height - this.pivot.y) : this.pivot.y;\r\n\r\n            this.pos.from.x = this.cursor.x;\r\n            this.pos.from.y = this.cursor.y;\r\n            layout.Position.apply(this.pos, this.target);\r\n        }\r\n\r\n        private onMouseUp(evt: MouseEvent): void {\r\n            evt.preventDefault();\r\n            evt.stopImmediatePropagation();\r\n            \r\n            if (this.target)\r\n                this.target.style.willChange = \"auto\";\r\n            this.target = null;\r\n\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/action/EventCircuit.ts",
      "size": 825,
      "sizeMinified": 431,
      "code": "namespace jsidea.action {\r\n    export class EventCircuit extends jsidea.events.EventDispatcher implements geom.IPoint2DValue {\r\n\r\n        public uid: number = 0;\r\n        public x: number = 0;\r\n        public y: number = 0;\r\n\r\n        constructor() {\r\n            super();\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/Builder.ts",
      "size": 325,
      "sizeMinified": 146,
      "code": "namespace jsidea.build {\r\n    export class Builder{\r\n            \r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/CompilerHost.ts",
      "size": 2186,
      "sizeMinified": 979,
      "code": "module jsidea.build {\r\n    export class CompilerHost extends FileSystem implements ts.CompilerHost {\r\n\r\n        constructor(files?: IFile[]) {\r\n            super(files);\r\n        }\r\n\r\n        public getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile {\r\n            var fi = this.find(fileName);\r\n            if (!fi) {\r\n                if (onError)\r\n                    onError(\"File not found: \" + fileName);\r\n                return null;\r\n            }\r\n            return ts.createSourceFile(fi.name, fi.code, languageVersion);\r\n        }\r\n        \r\n        public fileExists(fileName: string): boolean {\r\n            return this.exists(fileName);\r\n        }\r\n        \r\n        public readFile(fileName: string): string {\r\n            return this.read(fileName);\r\n        }\r\n        \r\n        public writeFile: ts.WriteFileCallback = (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void) => this.write(fileName, data);\r\n        \r\n        public getDefaultLibFileName(options: ts.CompilerOptions): string {\r\n            return \"\";\r\n        }\r\n        \r\n        public getCurrentDirectory(): string {\r\n            return \"\";\r\n        }\r\n        \r\n        public getCanonicalFileName(fileName: string): string {\r\n            return fileName;\r\n        }\r\n        \r\n        public useCaseSensitiveFileNames(): boolean {\r\n            return true;\r\n        }\r\n        \r\n        public getNewLine(): string {\r\n            return \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/FileSystem.ts",
      "size": 3173,
      "sizeMinified": 1085,
      "code": "module jsidea.build {\r\n    export class FileSystem implements IFileSystem {\r\n        public files: IFile[] = null;\r\n\r\n        constructor(files?: IFile[]) {\r\n            this.files = files || [];\r\n        }\r\n\r\n        public match(glob: string): IFile[] {\r\n            var res: IFile[] = [];\r\n            var r = FileSystem.globToRegex(glob);\r\n            for (var file of this.files)\r\n                if (r.test(file.name))\r\n                    res.push(file);\r\n            return res;\r\n        }\r\n\r\n        public find(fileName: string): IFile {\r\n            for (var f of this.files)\r\n                if (f.name == fileName)\r\n                    return f;\r\n            return null;\r\n        }\r\n        public exists(fileName: string): boolean {\r\n            return Boolean(this.find(fileName));\r\n        }\r\n\r\n        public read(fileName: string): string {\r\n            var f = this.find(fileName);\r\n            return f ? f.code : \"\";\r\n        }\r\n\r\n        public move(fileName: string, target: string): void {\r\n            var f = this.find(fileName);\r\n            if (!f)\r\n                return;\r\n            var t = this.find(target);\r\n            if (!t) {\r\n                f.name = target;\r\n                return;\r\n            }\r\n\r\n            var tidx = this.files.indexOf(t);\r\n            this.files.splice(tidx, 1);\r\n            f.name = target;\r\n        }\r\n\r\n        public write(fileName: string, data: string): void {\r\n            var f = this.find(fileName);\r\n            if (f)\r\n                f.code = data;\r\n            else\r\n                this.files.push({\r\n                    name: fileName,\r\n                    code: data\r\n                });\r\n        }\r\n        \r\n        private static globToRegex(glob: string): RegExp {\r\n            var specialChars = \"\\\\^$*+?.()|{}[]\";\r\n            var regexChars = [\"^\"];\r\n            for (var i = 0; i < glob.length; ++i) {\r\n                var c = glob.charAt(i);\r\n                switch (c) {\r\n                    case '?':\r\n                        regexChars.push(\".\");\r\n                        break;\r\n                    case '*':\r\n                        regexChars.push(\".*\");\r\n                        break;\r\n                    default:\r\n                        if (specialChars.indexOf(c) >= 0)\r\n                            regexChars.push(\"\\\\\");\r\n                        regexChars.push(c);\r\n                }\r\n            }\r\n            regexChars.push(\"$\");\r\n            return new RegExp(regexChars.join(\"\"));\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/IFile.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IFile {\r\n        name: string;\r\n        code: string;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/IFileSystem.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IFileSystem {\r\n        files: IFile[];\r\n        find(fileName: string): IFile;\r\n        match(glob: string): IFile[];\r\n        exists(fileName: string): boolean;\r\n        read(fileName: string): string;\r\n        write(fileName: string, data: string): void;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/IMinify.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IMinify {\r\n        apply(files: IFile[], options: any): IMinifyResult;\r\n    }\r\n}\r\n"
    },
    {
      "name": "src/jsidea/build/IMinifyResult.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IMinifyResult {\r\n        code: string;\r\n        map: string;\r\n    }\r\n}\r\n"
    },
    {
      "name": "src/jsidea/build/ISymbol.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface ISymbol {\r\n        fullName: string;\r\n        file: IFile;\r\n        kind: number;\r\n        imports: ISymbol[];\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/IUsage.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IUsage {\r\n        apply(files: IFile[], options?: any): IUsageResult;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/IUsageResult.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.build {\r\n    export interface IUsageResult {\r\n        symbols: ISymbol[];\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/build/Minify/JavaScript.ts",
      "size": 4264,
      "sizeMinified": 1454,
      "code": "namespace jsidea.build.Minify {\r\n    export interface IJavaScriptOptions extends UglifyJS.IOptions{\r\n\r\n    }\r\n    class JavaScriptMinify {\r\n        //SOURCE: https://gist.github.com/jpillora/5652641\r\n        //SOURCE: https://github.com/mishoo/UglifyJS2/blob/master/tools/node.js#L52\r\n        public apply(files: IFile[], options: IJavaScriptOptions): IMinifyResult {\r\n            options = UglifyJS.defaults(options, {\r\n                outSourceMap: null,\r\n                sourceRoot: null,\r\n                inSourceMap: null,\r\n                fromString: false,\r\n                warnings: false,\r\n                mangle: {},\r\n                output: null,\r\n                compress: {}\r\n            });\r\n            UglifyJS.base54.reset();\r\n\r\n            // 1. parse\r\n            var haveScope = false;\r\n            var toplevel = null,\r\n                sourcesContent = {};\r\n\r\n            files.forEach(function(file, i) {\r\n                var code = file.code;\r\n                sourcesContent[file.name] = code;\r\n                toplevel = UglifyJS.parse(code, {\r\n                    filename: options.fromString ? i : file.name,\r\n                    toplevel: toplevel\r\n                });\r\n            });\r\n\r\n            if (options.wrap)\r\n                toplevel = toplevel.wrap_commonjs(options.wrap, options.exportAll);\r\n\r\n            // 2. compress\r\n            if (options.compress) {\r\n                var compress = { warnings: options.warnings };\r\n                UglifyJS.merge(compress, options.compress);\r\n                toplevel.figure_out_scope();\r\n                haveScope = true;\r\n                var sq = UglifyJS.Compressor(compress);\r\n                toplevel = toplevel.transform(sq);\r\n            }\r\n\r\n            // 3. mangle\r\n            if (options.mangle) {\r\n                toplevel.figure_out_scope(options.mangle);\r\n                haveScope = true;\r\n                toplevel.compute_char_frequency(options.mangle);\r\n                toplevel.mangle_names(options.mangle);\r\n            }\r\n\r\n            // 4. scope (if needed)\r\n            if (!haveScope)\r\n                toplevel.figure_out_scope();\r\n\r\n            // 5. output\r\n            var inMap = options.inSourceMap;\r\n            var output: any = {};\r\n            if (typeof options.inSourceMap == \"string\")\r\n                inMap = options.inSourceMap;\r\n\r\n            if (options.outSourceMap) {\r\n                output.source_map = UglifyJS.SourceMap({\r\n                    file: options.outSourceMap,\r\n                    orig: inMap,\r\n                    root: options.sourceRoot\r\n                });\r\n                if (options.sourceMapIncludeSources) {\r\n                    for (var file in sourcesContent) {\r\n                        if (sourcesContent.hasOwnProperty(file))\r\n                            output.source_map.get().setSourceContent(file, sourcesContent[file]);\r\n                    }\r\n                }\r\n\r\n            }\r\n            if (options.output)\r\n                UglifyJS.merge(output, options.output);\r\n\r\n            var stream = UglifyJS.OutputStream(output);\r\n            toplevel.print(stream);\r\n\r\n            stream = stream.toString();\r\n            if (options.outSourceMap && \"string\" === typeof options.outSourceMap)\r\n                stream += \"\\n//# sourceMappingURL=\" + options.outSourceMap;\r\n\r\n            var source_map = output.source_map;\r\n            if (source_map)\r\n                source_map = source_map + \"\";\r\n\r\n            return {\r\n                code: stream,\r\n                map: source_map\r\n            };\r\n        }\r\n    }\r\n\r\n    export var JAVASCRIPT = new JavaScriptMinify();\r\n}\r\n\r\nif (UglifyJS)\r\n    UglifyJS.AST_Node.warn_function = (txt) => console.warn(txt);"
    },
    {
      "name": "src/jsidea/build/Usage/TypeScript.ts",
      "size": 7436,
      "sizeMinified": 2674,
      "code": "namespace jsidea.build.Usage {\r\n    export interface ITypeScriptOptions extends ts.CompilerOptions {\r\n\r\n    }\r\n    class TypeScriptUsage implements IUsage {\r\n\r\n        private _symbols: ISymbol[];\r\n        private _stack: ts.ModuleDeclaration[];\r\n        private _program: ts.Program;\r\n        private _file: IFile;\r\n\r\n        public apply(files: IFile[], options?: ITypeScriptOptions): IUsageResult {\r\n            options = options || { noLib: true };\r\n            this._stack = [];\r\n            this._symbols = [];\r\n\r\n            //create program\r\n            var host = new CompilerHost(files);\r\n            var names: string[] = [];\r\n            for (var f of files)\r\n                names.push(f.name);\r\n            this._program = ts.createProgram(names, options, host);\r\n            \r\n            //process exports\r\n            this._program.getSourceFiles().forEach(node => {\r\n                this._file = host.find(node.fileName);\r\n                if (node.fileName.indexOf(\".d.ts\") === -1)\r\n                    this.processExport(node);\r\n            });\r\n            \r\n            //process imports\r\n            this._stack = [];\r\n            this._program.getSourceFiles().forEach(node => {\r\n                this._file = host.find(node.fileName);\r\n                if (node.fileName.indexOf(\".d.ts\") === -1)\r\n                    this.processImport(node);\r\n            });\r\n\r\n            return {\r\n                symbols: this._symbols\r\n            };\r\n        }\r\n\r\n        private getFullName(node: ts.Node): string {\r\n            var symbol: ts.Symbol = this._program.getTypeChecker().getSymbolAtLocation(node);\r\n            if (!symbol)\r\n                symbol = (<any>node).symbol;\r\n            if (!symbol)\r\n                return \"\";\r\n            return this._program.getTypeChecker().getFullyQualifiedName(symbol);\r\n        }\r\n\r\n        private getName(node: ts.Node): string {\r\n            var path = this.getPath(node);\r\n            return path ? path[path.length - 1] : \"\";\r\n        }\r\n\r\n        private getPath(node: ts.Node): string[] {\r\n            var qname = this.getFullName(node);\r\n            if (qname)\r\n                return qname.split(\".\");\r\n            return null;\r\n        }\r\n\r\n        private processExport(node: ts.Node): void {\r\n            if (node.kind == ts.SyntaxKind.ModuleDeclaration)\r\n                this._stack.push(<ts.ModuleDeclaration>node);\r\n\r\n            switch (node.kind) {\r\n                case ts.SyntaxKind.ModuleDeclaration:\r\n                case ts.SyntaxKind.ClassDeclaration:\r\n                case ts.SyntaxKind.InterfaceDeclaration:\r\n                case ts.SyntaxKind.EnumDeclaration:\r\n                case ts.SyntaxKind.VariableDeclaration:\r\n                case ts.SyntaxKind.FunctionDeclaration:\r\n                    this.extractExportNames(node);\r\n            }\r\n\r\n            var skipChildren = node.kind == ts.SyntaxKind.ClassDeclaration;\r\n            if (!skipChildren)\r\n                ts.forEachChild(node, node => this.processExport(node));\r\n\r\n            if (node.kind == ts.SyntaxKind.ModuleDeclaration)\r\n                this._stack.pop();\r\n        }\r\n\r\n        private extractExportNames(node: ts.Node) {\r\n            var isNodeExported = false;\r\n            if (this._stack.length > 0) {\r\n                var name = this.getName(node);\r\n                var lastModule: any = this._stack[this._stack.length - 1];\r\n                isNodeExported = lastModule.symbol ? lastModule.symbol.exports.hasOwnProperty(name) : false;\r\n            }\r\n            if (isNodeExported) {\r\n                var fullName = this.getFullName(node);\r\n                this.addExport(fullName, node.kind);\r\n            }\r\n        }\r\n\r\n        private addExport(fullName: string, kind: any): void {\r\n            var s = this.getSymbolByName(fullName);\r\n            if (!s)\r\n                this._symbols.push({ fullName: fullName, kind: kind, file: this._file, imports: [] });\r\n        }\r\n\r\n        private processImport(node: ts.Node): void {\r\n            if (node.kind == ts.SyntaxKind.ModuleDeclaration)\r\n                this._stack.push(<ts.ModuleDeclaration>node);\r\n            \r\n            //TODO: remove of integrate some filter option\r\n            switch (node.kind) {\r\n//                case ts.SyntaxKind.Identifier:\r\n//                case ts.SyntaxKind.ExtendsKeyword:\r\n//                case ts.SyntaxKind.ClassKeyword:\r\n//                case ts.SyntaxKind.ClassExpression:\r\n//                case ts.SyntaxKind.ClassDeclaration:\r\n//                case ts.SyntaxKind.PropertyAccessExpression:\r\n                default:\r\n                    this.extractImportNames(node);\r\n            }\r\n\r\n            ts.forEachChild(node, node => this.processImport(node));\r\n\r\n            if (node.kind == ts.SyntaxKind.ModuleDeclaration)\r\n                this._stack.pop();\r\n        }\r\n\r\n        private extractImportNames(node: ts.Node): void {\r\n            var path = this.getPath(node);\r\n            if (node.kind == ts.SyntaxKind.ExpressionWithTypeArguments) {\r\n                var exp = <ts.ExpressionWithTypeArguments>node;\r\n                var signature = exp.expression.getText();\r\n                var stack = this._stack.map((a) => { return a.name.getText(); });\r\n                var mod = \"\";\r\n                this.addImport(signature);\r\n                if (signature && stack.length > 0) {\r\n                    for (var modName of stack) {\r\n                        mod += (mod ? \".\" : \"\") + modName;\r\n                        if (mod) {\r\n                            this.addImport(mod + \".\" + signature);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (path) {\r\n                var fullName: string = \"\";\r\n                var l = path.length;\r\n                for (var i = 0; i < l; ++i) {\r\n                    fullName += (fullName ? \".\" : \"\") + path[i];\r\n                    this.addImport(fullName);\r\n                }\r\n            }\r\n        }\r\n\r\n        private addImport(fullName: string): void {\r\n            var s = this.getSymbolByName(fullName);\r\n            if (s) {\r\n                var file = this._file;\r\n                for (var e of this._symbols)\r\n                    if (e != s && e.file == file && e.imports.indexOf(s) === -1)\r\n                        e.imports.push(s);\r\n            }\r\n        }\r\n\r\n        private getSymbolByName(fullName: string): ISymbol {\r\n            for (var s of this._symbols)\r\n                if (s.fullName == fullName)\r\n                    return s;\r\n            return null;\r\n        }\r\n    }\r\n\r\n    export var TYPESCRIPT = new TypeScriptUsage();\r\n}"
    },
    {
      "name": "src/jsidea/display/Graphics.ts",
      "size": 3362,
      "sizeMinified": 1436,
      "code": "namespace jsidea.display {\r\n    export class Graphics {\r\n\r\n        private static _instance: Graphics = new Graphics();\r\n        public static get(ctx: CanvasRenderingContext2D): Graphics {\r\n            Graphics._instance._ctx = ctx;\r\n            return Graphics._instance;\r\n        }\r\n\r\n        private _ctx: CanvasRenderingContext2D;\r\n\r\n        public bounds(element: HTMLElement, boxModel?: layout.IBoxModel): Graphics {\r\n            var ctx = this._ctx;\r\n            var can: HTMLElement = ctx.canvas;\r\n            boxModel = boxModel || layout.BoxModel.BORDER;\r\n\r\n            var from = layout.Transform.create(element);\r\n            var to = layout.Transform.create(can);\r\n            var quad = from.size.bounds(boxModel).toQuad();\r\n            quad = from.localToLocalQuad(to, quad, null, layout.BoxModel.CANVAS, quad);\r\n            this.quad(quad);\r\n\r\n            return this;\r\n        }\r\n\r\n        public strokeColor(color: string): Graphics {\r\n            var ctx = this._ctx;\r\n            ctx.strokeStyle = color;\r\n            return this;\r\n        }\r\n        \r\n        public lineWidth(lineWidth: number): Graphics {\r\n            var ctx = this._ctx;\r\n            ctx.lineWidth = lineWidth;\r\n            return this;\r\n        }\r\n\r\n        public stroke(color?: string, lineWidth?: number): Graphics {\r\n            var ctx = this._ctx;\r\n            ctx.closePath();\r\n            if (color !== undefined)\r\n                this.strokeColor(color);\r\n            if (lineWidth !== undefined)\r\n                this.lineWidth(lineWidth);\r\n            ctx.stroke();\r\n            ctx.beginPath();\r\n            return this;\r\n        }\r\n\r\n        public cross(x: number, y: number, size: number): Graphics {\r\n            var ctx = this._ctx;\r\n\r\n            ctx.moveTo(x + size, y);\r\n            ctx.lineTo(x - size, y);\r\n            ctx.moveTo(x, y + size);\r\n            ctx.lineTo(x, y - size);\r\n            return this;\r\n        }\r\n\r\n        public quad(quad: geom.Quad): Graphics {\r\n            var ctx = this._ctx;\r\n\r\n            ctx.moveTo(quad.p1.x, quad.p1.y);\r\n            ctx.lineTo(quad.p2.x, quad.p2.y);\r\n            ctx.lineTo(quad.p3.x, quad.p3.y);\r\n            ctx.lineTo(quad.p4.x, quad.p4.y);\r\n            ctx.lineTo(quad.p1.x, quad.p1.y);\r\n            return this;\r\n        }\r\n\r\n        public rect(box: geom.Rect2D): Graphics {\r\n            var ctx = this._ctx;\r\n\r\n            ctx.moveTo(box.x, box.y);\r\n            ctx.lineTo(box.x + box.width, box.y);\r\n            ctx.lineTo(box.x + box.width, box.y + box.height);\r\n            ctx.lineTo(box.x, box.y + box.height);\r\n            ctx.lineTo(box.x, box.y);\r\n            return this;\r\n        }\r\n\r\n        public clear(): Graphics {\r\n            var ctx = this._ctx;\r\n            ctx.closePath();\r\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n            ctx.beginPath();\r\n            return this;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/events/EventDispatcher.ts",
      "size": 2253,
      "sizeMinified": 870,
      "code": "namespace jsidea.events {\r\n    export class EventDispatcher implements IEventDispatcher {\r\n        \r\n        private _listener = new model.Dictonary<string, IEventListener[]>();\r\n        private _scope: any;\r\n\r\n        constructor(scope: any = null) {\r\n            this._scope = scope === null ? this : scope;\r\n        }\r\n\r\n        public addEventListener(\r\n            type: string,\r\n            listener: IEventListener,\r\n            useCapture: boolean = false): void {\r\n\r\n            var listeners = this.getListeners(type, useCapture);\r\n            var index = listeners.indexOf(listener);\r\n            if (index === -1)\r\n                listeners.push(listener);\r\n        }\r\n\r\n        public removeEventListener(\r\n            type: string,\r\n            listener: IEventListener,\r\n            useCapture: boolean = false): void {\r\n\r\n            var listeners = this.getListeners(type, useCapture);\r\n            var index = listeners.indexOf(listener);\r\n            if (index !== -1)\r\n                listeners.splice(index, 1);\r\n        }\r\n\r\n        public dispatchEvent(\r\n            event: Event): boolean {\r\n\r\n            var listeners = this.getListeners(event.type, false);\r\n            for (var i = 0; i < listeners.length; i++)\r\n                listeners[i].apply(this._scope, event);\r\n            return !event.defaultPrevented;\r\n        }\r\n\r\n        public getListeners(\r\n            type: string,\r\n            useCapture: boolean = false): IEventListener[] {\r\n            var key = type + (useCapture ? '1' : '0');\r\n            var listener = this._listener.getValue(key);\r\n            if (!listener)\r\n                return this._listener.setValue(key, []);\r\n            return listener;\r\n        }\r\n\r\n        public dispose(): void {\r\n            this._listener = null;\r\n            this._scope = null;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/events/Events.ts",
      "size": 892,
      "sizeMinified": 440,
      "code": "namespace jsidea.events {\r\n    export class Events {\r\n        //element events\r\n        public static BLUR: string = \"blur\";\r\n        \r\n        //image events\r\n        public static IMAGE_LOAD: string = \"load\";\r\n        \r\n        //keyboard events\r\n        public static KEY_DOWN: string = \"keydown\";\r\n        public static KEY_UP: string = \"keyup\";\r\n        public static KEY_PRESS: string = \"keypress\";\r\n        \r\n        //mouse events\r\n        public static MOUSE_CLICK: string = \"click\";\r\n        public static MOUSE_DOUBLE_CLICK: string = \"dblclick\";\r\n        public static MOUSE_DOWN: string = \"mousedown\";\r\n        public static MOUSE_MOVE: string = \"mousemove\";\r\n        public static MOUSE_UP: string = \"mouseup\";\r\n        public static MOUSE_OUT: string = \"mouseout\";\r\n        public static MOUSE_OVER: string = \"mouseover\";\r\n        public static MOUSE_DRAG: string = \"mousedrag\";\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/events/IEventDispatcher.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.events {\r\n    export interface IEventDispatcher extends EventTarget {\r\n        removeEventListener(type: string, useCapture?: any): void;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/events/IEventListener.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.events {\r\n    export interface IEventListener extends Function {\r\n        (e?: Event): any;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IComposition2D.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IComposition2D {\r\n        position: Point2D;\r\n        scale: Point2D;\r\n        skew: Point2D;\r\n        rotation: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IComposition3D.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IComposition3D {\r\n        perspective: number;\r\n        position: Point3D;\r\n        scale: Point3D;\r\n        skew: Point3D;\r\n        rotation: Point3D;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IMatrix2DValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IMatrix2DValue {\r\n        m11: number;\r\n        m12: number;\r\n        m13: number;\r\n        \r\n        m21: number;\r\n        m22: number;\r\n        m23: number;\r\n        \r\n        m31: number;\r\n        m32: number;\r\n        m33: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IMatrix3DValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IMatrix3DValue {\r\n        m11: number;\r\n        m12: number;\r\n        m13: number;\r\n        m14: number;\r\n        \r\n        m21: number;\r\n        m22: number;\r\n        m23: number;\r\n        m24: number;\r\n        \r\n        m31: number;\r\n        m32: number;\r\n        m33: number;\r\n        m34: number;\r\n        \r\n        m41: number;\r\n        m42: number;\r\n        m43: number;\r\n        m44: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IPoint2DValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IPoint2DValue {\r\n        x: number;\r\n        y: number;\r\n        w?: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IPoint3DValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IPoint3DValue extends IPoint2DValue {\r\n        z: number;\r\n        w: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IQuadValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IQuadValue {\r\n        p1: jsidea.geom.Point3D;\r\n        p2: jsidea.geom.Point3D;\r\n        p3: jsidea.geom.Point3D;\r\n        p4: jsidea.geom.Point3D;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/IRect2DValue.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.geom {\r\n    export interface IRect2DValue extends IPoint2DValue {\r\n        width: number;\r\n        height: number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/Matrix2D.ts",
      "size": 18690,
      "sizeMinified": 7879,
      "code": "namespace jsidea.geom {\r\n    /**\r\n    * Matrix2D math.\r\n    *  \r\n    * @author Jöran Benker\r\n    * \r\n    */\r\n    export class Matrix2D implements IMatrix2DValue {\r\n\r\n        public m11: number = 1;\r\n        public m12: number = 0;\r\n        public m13: number = 0;\r\n\r\n        public m21: number = 0;\r\n        public m22: number = 1;\r\n        public m23: number = 0;\r\n\r\n        public m31: number = 0;\r\n        public m32: number = 0;\r\n        public m33: number = 1;\r\n\r\n        constructor() {\r\n        }\r\n\r\n        public static create(element: HTMLElement = null, style: CSSStyleDeclaration = null, ret = new Matrix2D()): Matrix2D {\r\n            if (element && element.ownerDocument)\r\n                return ret.setCSS((style || window.getComputedStyle(element)).transform);\r\n            return ret.identity();\r\n        }\r\n\r\n        public getData(length: number = 6): number[] {\r\n            if (length == 9)\r\n                return [this.m11, this.m12, this.m13, this.m21, this.m22, this.m23, this.m31, this.m32, this.m33];\r\n            return [this.m11, this.m12, this.m21, this.m22, this.m31, this.m32];\r\n        }\r\n\r\n        public setData(data: number[]): Matrix2D {\r\n            if (data === undefined)\r\n                return this.identity();\r\n\r\n            var l = data.length;\r\n            if (l == 6) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = 0;\r\n                this.m21 = data[2];\r\n                this.m22 = data[3];\r\n                this.m23 = 0;\r\n                this.m31 = data[4];\r\n                this.m32 = data[5];\r\n                this.m33 = 1;\r\n            }\r\n            else if (l == 9) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = data[2];\r\n                this.m21 = data[3];\r\n                this.m22 = data[4];\r\n                this.m23 = data[5];\r\n                this.m31 = data[6];\r\n                this.m32 = data[7];\r\n                this.m33 = data[8];\r\n            }\r\n            else if (l == 16) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = data[3];\r\n                this.m21 = data[4];\r\n                this.m22 = data[5];\r\n                this.m23 = data[7];\r\n                this.m31 = data[12];\r\n                this.m32 = data[13];\r\n                this.m33 = data[15];\r\n            }\r\n            return this;\r\n        }\r\n\r\n        public copyFrom(matrix: IMatrix2DValue): Matrix2D {\r\n            this.m11 = matrix.m11;\r\n            this.m12 = matrix.m12;\r\n            this.m13 = matrix.m13;\r\n            this.m21 = matrix.m21;\r\n            this.m22 = matrix.m22;\r\n            this.m23 = matrix.m23;\r\n            this.m31 = matrix.m31;\r\n            this.m32 = matrix.m32;\r\n            this.m33 = matrix.m33;\r\n            return this;\r\n        }\r\n\r\n        public copyTo(matrix: IMatrix2DValue): Matrix2D {\r\n            matrix.m11 = this.m11;\r\n            matrix.m12 = this.m12;\r\n            matrix.m12 = this.m13;\r\n            matrix.m21 = this.m21;\r\n            matrix.m22 = this.m22;\r\n            matrix.m23 = this.m23;\r\n            matrix.m31 = this.m31;\r\n            matrix.m32 = this.m32;\r\n            matrix.m33 = this.m33;\r\n            return this;\r\n        }\r\n\r\n        public clone(): Matrix2D {\r\n            var m = new Matrix2D();\r\n            m.copyFrom(this);\r\n            return m;\r\n        }\r\n\r\n        public identity(): Matrix2D {\r\n            this.m11 = 1;\r\n            this.m12 = 0;\r\n            this.m13 = 0;\r\n            this.m21 = 0;\r\n            this.m22 = 1;\r\n            this.m23 = 0;\r\n            this.m31 = 0;\r\n            this.m32 = 0;\r\n            this.m33 = 1;\r\n            return this;\r\n        }\r\n\r\n        public isIdentity(): boolean {\r\n            return this.m11 == 1 &&\r\n                this.m12 == 0 &&\r\n                this.m13 == 0 &&\r\n                this.m21 == 0 &&\r\n                this.m22 == 1 &&\r\n                this.m23 == 0 &&\r\n                this.m31 == 0 &&\r\n                this.m32 == 0 &&\r\n                this.m33 == 1;\r\n        }\r\n\r\n        public scalar(scalar: number): Matrix2D {\r\n            this.m11 *= scalar;\r\n            this.m12 *= scalar;\r\n            this.m13 *= scalar;\r\n\r\n            this.m21 *= scalar;\r\n            this.m22 *= scalar;\r\n            this.m23 *= scalar;\r\n\r\n            this.m31 *= scalar;\r\n            this.m32 *= scalar;\r\n            this.m33 *= scalar;\r\n            return this;\r\n        }\r\n\r\n        public normalize(): Matrix2D {\r\n            var m33 = this.m33 || 0.0001;\r\n            return this.scalar(1 / m33);\r\n        }\r\n\r\n        public deltaTransform(point: IPoint2DValue, ret: Point2D = new Point2D()): Point2D {\r\n            return ret.setTo(\r\n                this.m11 * point.x + this.m21 * point.y,\r\n                this.m12 * point.x + this.m22 * point.y,\r\n                this.m13 * point.x + this.m23 * point.y);\r\n        }\r\n\r\n        public transform(point: IPoint2DValue, ret: Point2D = new Point2D()): Point2D {\r\n            var w = math.Number.parse(point.w, 1);\r\n            return ret.setTo(\r\n                this.m11 * point.x + this.m21 * point.y + this.m31 * w,\r\n                this.m12 * point.x + this.m22 * point.y + this.m32 * w,\r\n                this.m13 * point.x + this.m23 * point.y + this.m33 * w);\r\n        }\r\n\r\n        public append(matrix: IMatrix2DValue): Matrix2D {\r\n            return Matrix2D.multiply(this, matrix, this);\r\n        }\r\n\r\n        public prepend(matrix: IMatrix2DValue): Matrix2D {\r\n            return Matrix2D.multiply(matrix, this, this);\r\n        }\r\n\r\n        /**\r\n        * Get the decomposed position.\r\n        * @param ret Optional buffer.\r\n        * @return The position.\r\n        */\r\n        public getPosition(ret: Point2D = new Point2D()): Point2D {\r\n            ret.x = this.m31;\r\n            ret.y = this.m32;\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Sets the given position.\r\n        * @param position The new position.\r\n        * @return this-chained.\r\n        */\r\n        public setPosition(position: IPoint2DValue): Matrix2D {\r\n            this.m31 = position.x;\r\n            this.m32 = position.y;\r\n            return this;\r\n        }\r\n        \r\n        /**\r\n        * Creates a new position/translation-matrix.\r\n        * @param position The config object.\r\n        * @return The new translation-matrix.\r\n        */\r\n        public makePosition(offset: IPoint2DValue, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            ret.identity();\r\n            ret.m31 = offset.x;\r\n            ret.m32 = offset.y;\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n        * Appends position/offset.\r\n        * @param position The offset.\r\n        * @return this-chained.\r\n        */\r\n        public appendPosition(offset: IPoint2DValue): Matrix2D {\r\n            return this.append(this.makePosition(offset, _MATRIX2D));;\r\n        }\r\n\r\n        /**\r\n        * Prepends position/offset.\r\n        * @param position The offset.\r\n        * @return this-chained.\r\n        */\r\n        public prependPosition(offset: IPoint2DValue): Matrix2D {\r\n            return this.prepend(this.makePosition(offset, _MATRIX2D));\r\n        }\r\n        \r\n        /**\r\n        * Prepends position/offset.\r\n        * @param x The x-offset.\r\n        * @param y The y-offset.\r\n        * @param w The w-offset.\r\n        * @return this-chained.\r\n        */\r\n        public prependPositionRaw(x: number, y: number): Matrix2D {\r\n            return this.prependPosition(_POINT.setTo(x, y));\r\n        }\r\n\r\n        /**\r\n        * Get the decomposed scaling-factors.\r\n        * @param ret Optional buffer.\r\n        * @return The scaling-point.\r\n        */\r\n        public getScale(ret: Point2D = new Point2D()): Point2D {\r\n            ret.x = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12);\r\n            ret.y = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22);\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n        * Sets the given scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public setScale(pt: IPoint2DValue): Matrix2D {\r\n            this.m11 = pt.x;\r\n            this.m22 = pt.y;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Creates a new scaling-matrix.\r\n        * @param scale The scaling-factor.\r\n        * @return The new scaling-matrix.\r\n        */\r\n        public makeScale(scale: IPoint2DValue, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            ret.identity();\r\n            ret.setScale(scale);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public appendScale(scale: IPoint2DValue): Matrix2D {\r\n            this.append(this.makeScale(scale, _MATRIX2D));\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Prepends scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public prependScale(scale: IPoint2DValue): Matrix2D {\r\n            return this.prepend(this.makeScale(scale, _MATRIX2D));\r\n        }\r\n        \r\n        /**\r\n        * Prepends scaling-factors.\r\n        * @param x The x-scaling factor.\r\n        * @param y The y-scaling factor.\r\n        * @return this-chained.\r\n        */\r\n        public prependScaleRaw(x: number, y: number): Matrix2D {\r\n            return this.prependScale(_POINT.setTo(x, y));\r\n        }\r\n\r\n        /**\r\n        * Get the decomposed skewing-angles in degree.\r\n        * @param ret Optional buffer.\r\n        * @return The skewing-point.\r\n        */\r\n        public getSkew(ret: Point2D = new Point2D()): Point2D {\r\n            ret.setTo(\r\n                Math.atan2(-this.m21, this.m22) * math.Number.RAD_TO_DEG,\r\n                Math.atan2(this.m12, this.m11) * math.Number.RAD_TO_DEG);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Sets the given skewing angles in degree.\r\n        * @param scale The scaling factors.\r\n        * @return this-chained.\r\n        */\r\n        public setSkew(skew: IPoint2DValue): Matrix2D {\r\n            this.m11 = Math.cos(skew.y * math.Number.DEG_TO_RAD);\r\n            this.m12 = Math.sin(skew.y * math.Number.DEG_TO_RAD);\r\n            this.m21 = -Math.sin(skew.x * math.Number.DEG_TO_RAD);\r\n            this.m22 = Math.cos(skew.x * math.Number.DEG_TO_RAD);\r\n            return this;\r\n        }\r\n        \r\n        /**\r\n        * Create a new skewing-matrix.\r\n        * @param skew The skewing angles.\r\n        * @return The skewing-matrix.\r\n        */\r\n        public makeSkew(skew: IPoint2DValue, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            ret.identity();\r\n            ret.setSkew(skew);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends the given skewing-angles in degree.\r\n        * @param skew The skewing-angles.\r\n        * @return this-chained.\r\n        */\r\n        public appendSkew(skew: IPoint2DValue): Matrix2D {\r\n            return this.append(this.makeSkew(skew, _MATRIX2D));\r\n        }\r\n\r\n        /**\r\n        * Prepends the given skewing-angles in degree.\r\n        * @param skew The skewing-angles.\r\n        * @return this-chained.\r\n        */\r\n        public prependSkew(skew: IPoint2DValue): Matrix2D {\r\n            return this.prepend(this.makeSkew(skew, _MATRIX2D));\r\n        }\r\n        \r\n        /**\r\n        * Get the decomposed rotation-angle in degree.\r\n        * @param ret Optional buffer.\r\n        * @return The rotation-point.\r\n        */\r\n        public getRotation(): number {\r\n            var rotation = Math.atan2(this.m12, this.m11) * math.Number.RAD_TO_DEG;\r\n            if (this.m11 < 0 && this.m22 >= 0)\r\n                rotation += 180;\r\n            return rotation;\r\n        }\r\n\r\n        /**\r\n        * Sets the given rotation-angle in degree.\r\n        * @param scale The rotation-angles.\r\n        * @return this-chained.\r\n        */\r\n        public setRotation(rotation: number): Matrix2D {\r\n            var ro = this.getRotation();\r\n            ro += rotation - ro;\r\n            this.appendRotation(ro);\r\n            return this;\r\n        }\r\n        \r\n        /**\r\n        * Creates a new rotation-matrix.\r\n        * @param angle The rotations angle in degree.\r\n        * @return The rotation-matrix.\r\n        */\r\n        public makeRotation(angle: number, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            ret.identity();\r\n            ret.setRotation(angle);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends the given rotation-angle in degree.\r\n        * @param angle The rotation-angle in degree.\r\n        * @return this-chained.\r\n        */\r\n        public appendRotation(angle: number): Matrix2D {\r\n            angle *= math.Number.DEG_TO_RAD;\r\n\r\n            var m11: number = this.m11;\r\n            var m21: number = this.m21;\r\n            var m31: number = this.m31;\r\n\r\n            var THETA: number = Math.cos(angle);\r\n            var BETA: number = Math.sin(angle);\r\n            this.m11 = m11 * THETA - this.m12 * BETA;\r\n            this.m12 = m11 * BETA + this.m12 * THETA;\r\n            this.m21 = m21 * THETA - this.m22 * BETA;\r\n            this.m22 = m21 * BETA + this.m22 * THETA;\r\n            this.m31 = m31 * THETA - this.m32 * BETA;\r\n            this.m32 = m31 * BETA + this.m32 * THETA;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Prepends the given rotation-angle in degree.\r\n        * @param angle The rotation-angle in degree.\r\n        * @return this-chained.\r\n        */\r\n        public prependRotation(angle: number): Matrix2D {\r\n            return this.prepend(this.makeRotation(angle, _MATRIX2D));\r\n        }\r\n\r\n        public compose(target: IComposition2D): Matrix2D {\r\n            this.identity();\r\n            if (target.scale.x != 1 || target.scale.y != 1)\r\n                this.appendScale(target.scale);\r\n            if (target.skew.x || target.skew.y)\r\n                this.appendSkew(target.skew);\r\n            if (target.rotation != 0)\r\n                this.appendRotation(target.rotation);\r\n            if (target.position.x || target.position.y)\r\n                this.appendPosition(target.position);\r\n            return this;\r\n        }\r\n\r\n        public decompose(ret: IComposition2D = null): IComposition2D {\r\n            if (ret) {\r\n                ret.position = this.getPosition(ret.position);\r\n                ret.skew = this.getSkew(ret.skew);\r\n                ret.scale = this.getScale(ret.scale);\r\n                ret.rotation = this.getRotation();\r\n                return ret;\r\n            }\r\n            return {\r\n                position: this.getPosition(),\r\n                skew: this.getSkew(),\r\n                scale: this.getScale(),\r\n                rotation: this.getRotation()\r\n            };\r\n        }\r\n\r\n        public invert(): Matrix2D {\r\n            var m11: number = this.m11;\r\n            var m12: number = this.m12;\r\n            var m21: number = this.m21;\r\n            var m22: number = this.m22;\r\n            var m31: number = this.m31;\r\n            var n: number = m11 * m22 - m12 * m21;\r\n\r\n            this.m11 = m22 / n;\r\n            this.m12 = -m12 / n;\r\n            this.m21 = -m21 / n;\r\n            this.m22 = m11 / n;\r\n            this.m31 = (m21 * this.m32 - m22 * m31) / n;\r\n            this.m32 = -(m11 * this.m32 - m12 * m31) / n;\r\n\r\n            this.m13 = 0;\r\n            this.m23 = 0;\r\n            this.m33 = 1;\r\n\r\n            return this;\r\n        }\r\n\r\n        public getCSS(fractionalDigits: number = 6): string {\r\n            return \"matrix(\"\r\n                + this.m11.toFixed(fractionalDigits) + \",\"\r\n                + this.m12.toFixed(fractionalDigits) + \",\"\r\n                + this.m21.toFixed(fractionalDigits) + \",\"\r\n                + this.m22.toFixed(fractionalDigits) + \",\"\r\n                + this.m31.toFixed(fractionalDigits) + \",\"\r\n                + this.m32.toFixed(fractionalDigits) + \")\";\r\n        }\r\n\r\n        public getCSS3D(fractionalDigits: number = 6): string {\r\n            return \"matrix3d(\"\r\n                + this.m11.toFixed(fractionalDigits) + \",\"\r\n                + this.m12.toFixed(fractionalDigits) + \",\"\r\n                + 0 + \",\"\r\n                + this.m13.toFixed(fractionalDigits) + \",\"\r\n                + this.m21.toFixed(fractionalDigits) + \",\"\r\n                + this.m22.toFixed(fractionalDigits) + \",\"\r\n                + 0 + \",\"\r\n                + this.m23.toFixed(fractionalDigits) + \",\"\r\n                + 0 + \",\"\r\n                + 0 + \",\"\r\n                + 1 + \",\"\r\n                + 0 + \",\"\r\n                + this.m31.toFixed(fractionalDigits) + \",\"\r\n                + this.m32.toFixed(fractionalDigits) + \",\"\r\n                + 0 + \",\"\r\n                + this.m33.toFixed(fractionalDigits) + \")\";\r\n        }\r\n\r\n        public setCSS(cssString: string): Matrix2D {\r\n            if (!cssString || cssString == \"none\")\r\n                return this.identity();\r\n\r\n            var trans: any[] = cssString.replace(\"matrix3d(\", \"\").replace(\"matrix(\", \"\").replace(\")\", \"\").split(\",\");\r\n            var l = trans.length;\r\n            if (l < 6)\r\n                return this.identity();\r\n            for (var i = 0; i < l; ++i)\r\n                trans[i] = math.Number.parse(trans[i], 0);\r\n            this.setData(trans);\r\n\r\n            return this;\r\n        }\r\n\r\n        public static multiply(a: IMatrix2DValue, b: IMatrix2DValue, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            var data: number[] = _ARRAY;\r\n            data[0] = b.m11 * a.m11 + b.m12 * a.m21 + b.m13 * a.m31;\r\n            data[1] = b.m11 * a.m12 + b.m12 * a.m22 + b.m13 * a.m32;\r\n            data[2] = b.m11 * a.m13 + b.m12 * a.m23 + b.m13 * a.m33;\r\n\r\n            data[3] = b.m21 * a.m11 + b.m22 * a.m21 + b.m23 * a.m31;\r\n            data[4] = b.m21 * a.m12 + b.m22 * a.m22 + b.m23 * a.m32;\r\n            data[5] = b.m21 * a.m13 + b.m22 * a.m23 + b.m23 * a.m33;\r\n\r\n            data[6] = b.m31 * a.m11 + b.m32 * a.m21 + b.m33 * a.m31;\r\n            data[7] = b.m31 * a.m12 + b.m32 * a.m22 + b.m33 * a.m32;\r\n            data[8] = b.m31 * a.m13 + b.m32 * a.m23 + b.m33 * a.m33;\r\n            return ret.setData(data);\r\n        }\r\n\r\n        public static adjugate(matrix: Matrix2D, ret: Matrix2D = new Matrix2D()): Matrix2D {\r\n            var data: number[] = _ARRAY;\r\n            data[0] = matrix.m22 * matrix.m33 - matrix.m32 * matrix.m23;\r\n            data[1] = matrix.m32 * matrix.m13 - matrix.m12 * matrix.m33;\r\n            data[2] = matrix.m12 * matrix.m23 - matrix.m22 * matrix.m13;\r\n\r\n            data[3] = matrix.m31 * matrix.m23 - matrix.m21 * matrix.m33;\r\n            data[4] = matrix.m11 * matrix.m33 - matrix.m31 * matrix.m13;\r\n            data[5] = matrix.m21 * matrix.m13 - matrix.m11 * matrix.m23;\r\n\r\n            data[6] = matrix.m21 * matrix.m32 - matrix.m31 * matrix.m22;\r\n            data[7] = matrix.m31 * matrix.m12 - matrix.m11 * matrix.m32;\r\n            data[8] = matrix.m11 * matrix.m22 - matrix.m21 * matrix.m12;\r\n            return ret.setData(data);\r\n        }\r\n\r\n        public toStringTable(fractionDigits: number = 3): string {\r\n            return \"m11=\" + this.m11.toFixed(fractionDigits)\r\n                + \"\\tm21=\" + this.m21.toFixed(fractionDigits)\r\n                + \"\\tm31=\" + this.m31.toFixed(fractionDigits)\r\n                + \"\\nm12=\" + this.m12.toFixed(fractionDigits)\r\n                + \"\\tm22=\" + this.m22.toFixed(fractionDigits)\r\n                + \"\\tm32=\" + this.m32.toFixed(fractionDigits)\r\n                + \"\\nm13=\" + this.m13.toFixed(fractionDigits)\r\n                + \"\\tm23=\" + this.m23.toFixed(fractionDigits)\r\n                + \"\\tm33=\" + this.m33.toFixed(fractionDigits);\r\n        }\r\n    }\r\n\r\n    var _ARRAY = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    var _MATRIX2D = new Matrix2D();\r\n    var _POINT = new Point2D();\r\n}"
    },
    {
      "name": "src/jsidea/geom/Matrix3D.ts",
      "size": 31985,
      "sizeMinified": 13300,
      "code": "namespace jsidea.geom {\r\n    /**\r\n    * Matrix3D math.\r\n    *  \r\n    * @author Jöran Benker\r\n    * \r\n    */\r\n    export class Matrix3D implements IMatrix3DValue {\r\n\r\n        public m11: number = 1;\r\n        public m12: number = 0;\r\n        public m13: number = 0;\r\n        public m14: number = 0;\r\n        public m21: number = 0;\r\n        public m22: number = 1;\r\n        public m23: number = 0;\r\n        public m24: number = 0;\r\n        public m31: number = 0;\r\n        public m32: number = 0;\r\n        public m33: number = 1;\r\n        public m34: number = 0;\r\n        public m41: number = 0;\r\n        public m42: number = 0;\r\n        public m43: number = 0;\r\n        public m44: number = 1;\r\n\r\n        constructor() {\r\n        }\r\n\r\n        public static create(element: HTMLElement, style: CSSStyleDeclaration = null, ret = new Matrix3D()): Matrix3D {\r\n            if (element && element.ownerDocument)\r\n                return ret.setCSS((style || window.getComputedStyle(element)).transform);\r\n            return ret.identity();\r\n        }\r\n\r\n        public getData(): number[] {\r\n            return [\r\n                this.m11, this.m12, this.m13, this.m14,//column 1\r\n                this.m21, this.m22, this.m23, this.m24,//column 2\r\n                this.m31, this.m32, this.m33, this.m34,//column 3\r\n                this.m41, this.m42, this.m43, this.m44 //column 4\r\n            ];\r\n        }\r\n\r\n        public setData(data: number[]): Matrix3D {\r\n            if (data === undefined)\r\n                return;\r\n\r\n            var l = data.length;\r\n            if (l == 16) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = data[2];\r\n                this.m14 = data[3];\r\n                this.m21 = data[4];\r\n                this.m22 = data[5];\r\n                this.m23 = data[6];\r\n                this.m24 = data[7];\r\n                this.m31 = data[8];\r\n                this.m32 = data[9];\r\n                this.m33 = data[10];\r\n                this.m34 = data[11];\r\n                this.m41 = data[12];\r\n                this.m42 = data[13];\r\n                this.m43 = data[14];\r\n                this.m44 = data[15];\r\n            }\r\n            else if (l == 6) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = 0;\r\n                this.m14 = 0;\r\n                this.m21 = data[2];\r\n                this.m22 = data[3];\r\n                this.m23 = 0;\r\n                this.m24 = 0;\r\n                this.m31 = 0;\r\n                this.m32 = 0;\r\n                this.m33 = 1;\r\n                this.m34 = 0;\r\n                this.m41 = data[4];\r\n                this.m42 = data[5];\r\n                this.m43 = 0;\r\n                this.m44 = 1;\r\n            }\r\n            else if (l == 9) {\r\n                this.m11 = data[0];\r\n                this.m12 = data[1];\r\n                this.m13 = 0;\r\n                this.m14 = data[2];\r\n                this.m21 = data[3];\r\n                this.m22 = data[4];\r\n                this.m23 = 0;\r\n                this.m24 = data[5];\r\n                this.m31 = 0;\r\n                this.m32 = 0;\r\n                this.m33 = 1;\r\n                this.m34 = 0;\r\n                this.m41 = data[6];\r\n                this.m42 = data[7];\r\n                this.m43 = 0;\r\n                this.m44 = data[8];\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        public copyFrom(matrix: IMatrix3DValue): Matrix3D {\r\n            this.m11 = matrix.m11;\r\n            this.m12 = matrix.m12;\r\n            this.m13 = matrix.m13;\r\n            this.m14 = matrix.m14;\r\n            this.m21 = matrix.m21;\r\n            this.m22 = matrix.m22;\r\n            this.m23 = matrix.m23;\r\n            this.m24 = matrix.m24;\r\n            this.m31 = matrix.m31;\r\n            this.m32 = matrix.m32;\r\n            this.m33 = matrix.m33;\r\n            this.m34 = matrix.m34;\r\n            this.m41 = matrix.m41;\r\n            this.m42 = matrix.m42;\r\n            this.m43 = matrix.m43;\r\n            this.m44 = matrix.m44;\r\n            return this;\r\n        }\r\n\r\n        public clone(): Matrix3D {\r\n            return (new Matrix3D()).copyFrom(this);\r\n        }\r\n\r\n        public identity(): Matrix3D {\r\n            this.m11 = 1;\r\n            this.m12 = 0;\r\n            this.m13 = 0;\r\n            this.m14 = 0;\r\n            this.m21 = 0;\r\n            this.m22 = 1;\r\n            this.m23 = 0;\r\n            this.m24 = 0;\r\n            this.m31 = 0;\r\n            this.m32 = 0;\r\n            this.m33 = 1;\r\n            this.m34 = 0;\r\n            this.m41 = 0;\r\n            this.m42 = 0;\r\n            this.m43 = 0;\r\n            this.m44 = 1;\r\n            return this;\r\n        }\r\n\r\n        public isIdentity(): boolean {\r\n            return this.m11 == 1 &&\r\n                this.m12 == 0 &&\r\n                this.m13 == 0 &&\r\n                this.m14 == 0 &&\r\n                this.m21 == 0 &&\r\n                this.m22 == 1 &&\r\n                this.m23 == 0 &&\r\n                this.m24 == 0 &&\r\n                this.m31 == 0 &&\r\n                this.m32 == 0 &&\r\n                this.m33 == 1 &&\r\n                this.m34 == 0 &&\r\n                this.m41 == 0 &&\r\n                this.m42 == 0 &&\r\n                this.m43 == 0 &&\r\n                this.m44 == 1;\r\n        }\r\n\r\n        public scalar(scalar: number): Matrix3D {\r\n            this.m11 *= scalar;\r\n            this.m12 *= scalar;\r\n            this.m13 *= scalar;\r\n            this.m14 *= scalar;\r\n            this.m21 *= scalar;\r\n            this.m22 *= scalar;\r\n            this.m23 *= scalar;\r\n            this.m24 *= scalar;\r\n            this.m31 *= scalar;\r\n            this.m32 *= scalar;\r\n            this.m33 *= scalar;\r\n            this.m34 *= scalar;\r\n            this.m41 *= scalar;\r\n            this.m42 *= scalar;\r\n            this.m43 *= scalar;\r\n            this.m44 *= scalar;\r\n\r\n            return this;\r\n        }\r\n\r\n        public normalize(): Matrix3D {\r\n            return this.scalar(1 / (this.m44 || 0.0001));\r\n        }\r\n        \r\n        //based on http://code.metager.de/source/xref/mozilla/B2G/gecko/gfx/thebes/gfx3DMatrix.cpp#651\r\n        public unproject(point: IPoint2DValue, ret: Point3D = new Point3D()): Point3D {\r\n            var x = point.x * this.m11 + point.y * this.m21 + this.m41;\r\n            var y = point.x * this.m12 + point.y * this.m22 + this.m42;\r\n            var z = point.x * this.m13 + point.y * this.m23 + this.m43;\r\n            var w = point.x * this.m14 + point.y * this.m24 + this.m44;\r\n\r\n            var qx = x + this.m31;\r\n            var qy = y + this.m32;\r\n            var qz = z + this.m33;\r\n            var qw = w + this.m34;\r\n\r\n            if (w == 0)\r\n                w = 0.0001;\r\n            x /= w;\r\n            y /= w;\r\n            z /= w;\r\n\r\n            if (qw == 0)\r\n                qw = 0.0001;\r\n            qx /= qw;\r\n            qy /= qw;\r\n            qz /= qw;\r\n\r\n            //TODO: ....\r\n            var wz = qz - z;\r\n            if (wz == 0)\r\n                return ret.setTo(x, y, z, w);\r\n\r\n            var t = -z / wz;\r\n            x += t * (qx - x);\r\n            y += t * (qy - y);\r\n\r\n            return ret.setTo(x, y, z, w);\r\n        }\r\n\r\n        //from homegeneous (euclid) to cartesian FLATTENED!!!! like a projection\r\n        public project(point: IPoint3DValue, ret: Point3D = new Point3D()): Point3D {\r\n            var z = point.z;\r\n            var w = point.x * this.m14 + point.y * this.m24 + z * this.m34 + this.m44;\r\n            var x = point.x * this.m11 + point.y * this.m21 + z * this.m31 + this.m41;\r\n            var y = point.x * this.m12 + point.y * this.m22 + z * this.m32 + this.m42;\r\n\r\n            if (w == 0)\r\n                w = 0.0001;\r\n\r\n            x /= w;\r\n            y /= w;\r\n\r\n            //lets call it \"hasenfuss\"\r\n            //look at the developer tools of firefox and chrome -> \r\n            //ff and chrome do it wrong: the highlighted bounding box failed to be correct\r\n            //and getBoundingClientRect also\r\n            \r\n            //behind the \"camera\" (z > 0)\r\n            if (w < 0) {\r\n                x -= this.m41;\r\n                y -= this.m42;\r\n                x *= 1 / w;\r\n                y *= 1 / w;\r\n                x += this.m41;\r\n                y += this.m42;\r\n            }\r\n\r\n            return ret.setTo(x, y, z, w);\r\n        }\r\n\r\n        public transform(point: IPoint3DValue, ret: Point3D = new Point3D()): Point3D {\r\n            var x = point.x * this.m11 + point.y * this.m21 + point.z * this.m31 + point.w * this.m41;\r\n            var y = point.x * this.m12 + point.y * this.m22 + point.z * this.m32 + point.w * this.m42;\r\n            var z = point.x * this.m13 + point.y * this.m23 + point.z * this.m33 + point.w * this.m43;\r\n            var w = point.x * this.m14 + point.y * this.m24 + point.z * this.m34 + point.w * this.m44;\r\n\r\n            return ret.setTo(x, y, z, w);\r\n        }\r\n\r\n        public transformRaw(x: number, y: number, z: number, ret: Point3D = new Point3D()): Point3D {\r\n            return this.transform(Matrix3D._POINT.setTo(x, y, z), ret);\r\n        }\r\n\r\n        public append(b: IMatrix3DValue): Matrix3D {\r\n            return Matrix3D.multiply(this, b, this);\r\n        }\r\n\r\n        public prepend(b: IMatrix3DValue): Matrix3D {\r\n            return Matrix3D.multiply(b, this, this);\r\n        }\r\n        \r\n        /**\r\n        * Get the decomposed position.\r\n        * @param ret Optional buffer.\r\n        * @return The position.\r\n        */\r\n        public getPosition(ret: Point3D = new Point3D()): Point3D {\r\n            ret.x = this.m41;\r\n            ret.y = this.m42;\r\n            ret.z = this.m43;\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Sets the given position.\r\n        * @param position The new position.\r\n        * @return this-chained.\r\n        */\r\n        public setPosition(position: IPoint3DValue): Matrix3D {\r\n            this.m41 = position.x;\r\n            this.m42 = position.y;\r\n            this.m43 = position.z;\r\n            return this;\r\n        }\r\n        \r\n        /**\r\n        * Sets the given position.\r\n        * @param position The new position.\r\n        * @return this-chained.\r\n        */\r\n        public setPositionSafe(position: IPoint3DValue): Matrix3D {\r\n            if (!isNaN(position.x))\r\n                this.m41 = position.x;\r\n            if (!isNaN(position.y))\r\n                this.m42 = position.y;\r\n            if (!isNaN(position.z))\r\n                this.m43 = position.z;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Creates a new position/translation-matrix.\r\n        * @param position The config object.\r\n        * @return The new translation-matrix.\r\n        */\r\n        public static makePosition(position: IPoint3DValue, ret = new Matrix3D()): Matrix3D {\r\n            ret.identity();\r\n            ret.setPosition(position);\r\n            return ret;\r\n        }\r\n\r\n        \r\n        /**\r\n        * Appends position/offset.\r\n        * @param position The offset.\r\n        * @return this-chained.\r\n        */\r\n        public appendPosition(position: IPoint3DValue): Matrix3D {\r\n            return this.append(Matrix3D.makePosition(position, Matrix3D._MATRIX3D));\r\n        }\r\n        \r\n        /**\r\n        * Appends position/offset.\r\n        * @param x The x-offset.\r\n        * @param y The y-offset.\r\n        * @param y The z-offset.\r\n        * @return this-chained.\r\n        */\r\n        public appendPositionRaw(x: number, y: number, z: number): Matrix3D {\r\n            return this.appendPosition(Matrix3D._POINT.setTo(x, y, z));\r\n        }\r\n\r\n        /**\r\n        * Prepends position/offset.\r\n        * @param position The offset.\r\n        * @return this-chained.\r\n        */\r\n        public prependPosition(position: IPoint3DValue): Matrix3D {\r\n            return this.prepend(Matrix3D.makePosition(position, Matrix3D._MATRIX3D));\r\n        }   \r\n        \r\n        /**\r\n        * Prepends position/offset.\r\n        * @param x The x-offset.\r\n        * @param y The y-offset.\r\n        * @param y The z-offset.\r\n        * @return this-chained.\r\n        */\r\n\r\n        public prependPositionRaw(x: number, y: number, z: number): Matrix3D {\r\n            return this.prependPosition(Matrix3D._POINT.setTo(x, y, z, 0));\r\n        }\r\n        \r\n        /**\r\n        * Get the decomposed scaling-factors.\r\n        * @param ret Optional buffer.\r\n        * @return The scaling-point.\r\n        */\r\n        public getScale(ret: Point3D = new Point3D()): Point3D {\r\n            ret.x = Math.sqrt(this.m11 * this.m11 + this.m12 * this.m12 + this.m13 * this.m13);\r\n            ret.y = Math.sqrt(this.m21 * this.m21 + this.m22 * this.m22 + this.m23 * this.m23);\r\n            ret.z = Math.sqrt(this.m31 * this.m31 + this.m32 * this.m32 + this.m33 * this.m33);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Sets the given scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public setScale(scale: IPoint3DValue): Matrix3D {\r\n            this.m11 = scale.x;\r\n            this.m22 = scale.y;\r\n            this.m33 = scale.z;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Creates a new scaling-matrix.\r\n        * @param scale The scaling-factor.\r\n        * @return The new scaling-matrix.\r\n        */\r\n        public static makeScale(scale: IPoint3DValue, ret = new Matrix3D()): Matrix3D {\r\n            ret.identity();\r\n            ret.setScale(scale);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public appendScale(scale: IPoint3DValue): Matrix3D {\r\n            return this.append(Matrix3D.makeScale(scale, Matrix3D._MATRIX3D));\r\n        }\r\n        \r\n        /**\r\n        * Appends scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public appendScaleRaw(x: number, y: number, z: number): Matrix3D {\r\n            return this.appendScale(Matrix3D._POINT.setTo(x, y, z));\r\n        }\r\n\r\n        /**\r\n        * Prepends scaling-factors.\r\n        * @param scale The scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public prependScale(scale: IPoint3DValue): Matrix3D {\r\n            return this.prepend(Matrix3D.makeScale(scale, Matrix3D._MATRIX3D));\r\n        }\r\n        \r\n        /**\r\n        * Prepends scaling-factors.\r\n        * @param x The x scaling-factor.\r\n        * @param y The y scaling-factor.\r\n        * @param z The z scaling-factor.\r\n        * @return this-chained.\r\n        */\r\n        public prependScaleRaw(x: number, y: number, z: number): Matrix3D {\r\n            return this.prependScale(Matrix3D._POINT.setTo(x, y, z));\r\n        }\r\n        \r\n        /**\r\n        * Get the decomposed skewing-angles in degree.\r\n        * @param ret Optional buffer.\r\n        * @return The skewing-point.\r\n        */\r\n        public getSkew(ret: Point3D = new Point3D()): Point3D {\r\n            ret.x = this.m14 * math.Number.RAD_TO_DEG;\r\n            ret.y = this.m24 * math.Number.RAD_TO_DEG;\r\n            ret.z = this.m34 * math.Number.RAD_TO_DEG;\r\n            ret.w = this.m44;\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n        * Sets the given skewing angles in degree.\r\n        * @param scale The scaling factors.\r\n        * @return this-chained.\r\n        */\r\n        public setSkew(skew: IPoint3DValue): Matrix3D {\r\n            this.m14 = skew.x * math.Number.DEG_TO_RAD;\r\n            this.m24 = skew.y * math.Number.DEG_TO_RAD;\r\n            this.m34 = skew.z * math.Number.DEG_TO_RAD;\r\n            this.m44 = skew.w;\r\n            return this;\r\n        }\r\n        \r\n        /**\r\n        * Sets the given skewing angles in degree.\r\n        * @param x The x-skewing angle.\r\n        * @param y The y-skewing angle.\r\n        * @param z The z-skewing angle.\r\n        * @return this-chained.\r\n        */\r\n\r\n        public setSkewRaw(x: number, y: number, z: number): Matrix3D {\r\n            return this.setSkew(Matrix3D._POINT.setTo(x, y, z));\r\n        }\r\n\r\n        /**\r\n        * Create a new skewing-matrix.\r\n        * @param skew The skewing angles.\r\n        * @return The skewing-matrix.\r\n        */\r\n        public static makeSkew(skew: IPoint3DValue, ret: Matrix3D = new Matrix3D()): Matrix3D {\r\n            ret.identity();\r\n            ret.setSkew(skew);\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends the given skewing-angles in degree.\r\n        * @param skew The skewing-angles.\r\n        * @return this-chained.\r\n        */\r\n        public appendSkew(skew: IPoint3DValue): Matrix3D {\r\n            return this.append(Matrix3D.makeSkew(skew, Matrix3D._MATRIX3D));\r\n        }\r\n\r\n        /**\r\n        * Prepends the given skewing-angles in degree.\r\n        * @param skew The skewing-angles.\r\n        * @return this-chained.\r\n        */\r\n        public prependSkew(skew: IPoint3DValue): Matrix3D {\r\n            return this.prepend(Matrix3D.makeSkew(skew, Matrix3D._MATRIX3D));\r\n        }\r\n        \r\n        /**\r\n        * Get the decomposed rotation-angles in degree (xyz-order).\r\n        * @param ret Optional buffer.\r\n        * @return The rotation-point.\r\n        */\r\n        public getRotation(ret: Point3D = new Point3D()): Point3D {\r\n            var m = this.getRotationMatrix(Matrix3D._MATRIX3D);\r\n            ret.y = -Math.asin(math.Number.clamp(m.m13, -1, 1)) * math.Number.RAD_TO_DEG;\r\n            if (Math.abs(this.m13) < 0.99999) {\r\n                ret.x = Math.atan2(-m.m23, m.m33) * math.Number.RAD_TO_DEG;\r\n                ret.z = Math.atan2(-m.m12, m.m11) * math.Number.RAD_TO_DEG;\r\n            } else {\r\n                ret.x = Math.atan2(m.m32, m.m22) * math.Number.RAD_TO_DEG;\r\n                ret.z = 0;\r\n            }\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n        * Sets the given rotation-angles in degree (xyz-order).\r\n        * SOURCE: https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js\r\n        * @param scale The rotation-angles.\r\n        * @return this-chained.\r\n        */\r\n        public setRotation(euler: IPoint3DValue): Matrix3D {\r\n            var x = euler.x * math.Number.DEG_TO_RAD;\r\n            var y = euler.y * math.Number.DEG_TO_RAD;\r\n            var z = euler.z * math.Number.DEG_TO_RAD;\r\n            var a = Math.cos(x);\r\n            var b = Math.sin(x);\r\n            var c = Math.cos(y);\r\n            var d = Math.sin(y);\r\n            var e = Math.cos(z);\r\n            var f = Math.sin(z);\r\n\r\n            var ae = a * e;\r\n            var af = a * f;\r\n            var be = b * e;\r\n            var bf = b * f;\r\n\r\n            this.m11 = c * e;\r\n            this.m21 = -c * f;\r\n            this.m31 = d;\r\n            this.m12 = af + be * d;\r\n            this.m22 = ae - bf * d;\r\n            this.m32 = -b * c;\r\n            this.m13 = bf - ae * d;\r\n            this.m23 = be + af * d;\r\n            this.m33 = a * c;\r\n\r\n            return this;\r\n        }\r\n\r\n        public static makeRotation(euler: IPoint3DValue): Matrix3D {\r\n            var ret = new Matrix3D();\r\n            ret.setRotation(euler);\r\n            return ret;\r\n        }\r\n\r\n        public appendRotation(euler: IPoint3DValue): Matrix3D {\r\n            return this.append(Matrix3D.makeRotation(euler));\r\n        }\r\n\r\n        public prependRotation(euler: IPoint3DValue): Matrix3D {\r\n            return this.prepend(Matrix3D.makeRotation(euler));\r\n        }\r\n\r\n        public getRotationMatrix(ret: Matrix3D = new Matrix3D()): Matrix3D {\r\n            ret.identity();\r\n\r\n            var tmp = new Point3D();\r\n            var scaleX = 1 / tmp.setTo(this.m11, this.m12, this.m13).length();\r\n            var scaleY = 1 / tmp.setTo(this.m21, this.m22, this.m23).length();\r\n            var scaleZ = 1 / tmp.setTo(this.m31, this.m32, this.m33).length();\r\n\r\n            ret.m11 = this.m11 * scaleX;\r\n            ret.m12 = this.m12 * scaleX;\r\n            ret.m13 = this.m13 * scaleX;\r\n            ret.m21 = this.m21 * scaleY;\r\n            ret.m22 = this.m22 * scaleY;\r\n            ret.m23 = this.m23 * scaleY;\r\n            ret.m31 = this.m31 * scaleZ;\r\n            ret.m32 = this.m32 * scaleZ;\r\n            ret.m33 = this.m33 * scaleZ;\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n       * Creates a new perspective-matrix.\r\n       * @param perspective The perspective.\r\n       * @return The new perspective-matrix.\r\n       */\r\n        public static makePerspective(perspective: number, ret = new Matrix3D()): Matrix3D {\r\n            ret.identity();\r\n            ret.m34 = perspective ? -(1 / perspective) : 0;\r\n            return ret;\r\n        }\r\n\r\n        /**\r\n        * Appends perspective.\r\n        * @param perspective The perspective (focal length).\r\n        * @return this-chained.\r\n        */\r\n        public appendPerspective(perspective: number): Matrix3D {\r\n            if (!perspective)\r\n                return this;\r\n            return this.append(Matrix3D.makePerspective(perspective, Matrix3D._MATRIX3D));\r\n        }\r\n\r\n        /**\r\n        * Prepends perspective.\r\n        * @param perspective The perspective (focal length).\r\n        * @return this-chained.\r\n        */\r\n        public prependPerspective(perspective: number): Matrix3D {\r\n            return this.prepend(Matrix3D.makePerspective(perspective, Matrix3D._MATRIX3D));\r\n        }\r\n\r\n        public getPerspective(): number {\r\n            return this.m34 ? - (1 / this.m34) : 0;\r\n        }\r\n\r\n        public setPerspective(perspective: number): Matrix3D {\r\n            this.m34 = perspective ? -(1 / perspective) : 0;\r\n            return this;\r\n        }\r\n\r\n        public compose(trans: IComposition3D): Matrix3D {\r\n            this.identity();\r\n            if (trans.scale.x != 1 || trans.scale.y != 1 || trans.scale.z != 1)\r\n                this.appendScale(trans.scale);\r\n            if (trans.skew.x || trans.skew.y || trans.skew.z)\r\n                this.appendSkew(trans.skew);\r\n            if (trans.rotation.x != 0 || trans.rotation.y != 0 || trans.rotation.z != 0)\r\n                this.appendRotation(trans.rotation);\r\n            if (trans.position.x || trans.position.y || trans.position.z)\r\n                this.appendPosition(trans.position);\r\n            if (trans.perspective)\r\n                this.appendPerspective(trans.perspective);\r\n            return this;\r\n        }\r\n\r\n        public decompose(ret: IComposition3D = null): IComposition3D {\r\n            if (ret) {\r\n                ret.perspective = this.getPerspective();\r\n                ret.position = this.getPosition(ret.position);\r\n                ret.skew = this.getSkew(ret.skew);\r\n                ret.scale = this.getScale(ret.scale);\r\n                ret.rotation = this.getRotation(ret.rotation);\r\n                return ret;\r\n            }\r\n            return {\r\n                perspective: this.getPerspective(),\r\n                position: this.getPosition(),\r\n                skew: this.getSkew(),\r\n                scale: this.getScale(),\r\n                rotation: this.getRotation()\r\n            };\r\n        }\r\n        \r\n        /**\r\n        * Inverts the matrix.\r\n        * -> based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n        * -> based on https://github.com/mrdoob/three.js/blob/master/src/math/Matrix4.js\r\n        * @return this-chained.\r\n        */\r\n        public invert(target?: Matrix3D): Matrix3D {\r\n            target = target || this;\r\n            var data: number[] = [];\r\n\r\n            var n11 = this.m11, n12 = this.m12, n13 = this.m13, n14 = this.m14;\r\n            var n21 = this.m21, n22 = this.m22, n23 = this.m23, n24 = this.m24;\r\n            var n31 = this.m31, n32 = this.m32, n33 = this.m33, n34 = this.m34;\r\n            var n41 = this.m41, n42 = this.m42, n43 = this.m43, n44 = this.m44;\r\n\r\n            data[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n            data[1] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n            data[2] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n            data[3] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n            var det = n11 * data[0] + n21 * data[1] + n31 * data[2] + n41 * data[3];\r\n            if (det == 0) {\r\n                console.warn(\"Can't invert matrix, determinant is 0\");\r\n                return this;\r\n            }\r\n\r\n            data[4] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n            data[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n            data[6] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n            data[7] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n            data[8] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n            data[9] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n            data[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n            data[11] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n            data[12] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n            data[13] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n            data[14] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n            data[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n            target.setData(data);\r\n            target.scalar(1 / det);\r\n            return target;\r\n        }\r\n\r\n        public getCSS2D(fractionalDigits: number = 6): string {\r\n            return \"matrix(\"\r\n                + this.m11.toFixed(fractionalDigits) + \",\"\r\n                + this.m12.toFixed(fractionalDigits) + \",\"\r\n                + this.m21.toFixed(fractionalDigits) + \",\"\r\n                + this.m22.toFixed(fractionalDigits) + \",\"\r\n                + this.m41.toFixed(fractionalDigits) + \",\"\r\n                + this.m42.toFixed(fractionalDigits) + \")\";\r\n        }\r\n\r\n        public getCSS(fractionalDigits: number = 6): string {\r\n            return \"matrix3d(\"\r\n                + this.m11.toFixed(fractionalDigits) + \",\"\r\n                + this.m12.toFixed(fractionalDigits) + \",\"\r\n                + this.m13.toFixed(fractionalDigits) + \",\"\r\n                + this.m14.toFixed(fractionalDigits) + \",\"\r\n                + this.m21.toFixed(fractionalDigits) + \",\"\r\n                + this.m22.toFixed(fractionalDigits) + \",\"\r\n                + this.m23.toFixed(fractionalDigits) + \",\"\r\n                + this.m24.toFixed(fractionalDigits) + \",\"\r\n                + this.m31.toFixed(fractionalDigits) + \",\"\r\n                + this.m32.toFixed(fractionalDigits) + \",\"\r\n                + this.m33.toFixed(fractionalDigits) + \",\"\r\n                + this.m34.toFixed(fractionalDigits) + \",\"\r\n                + this.m41.toFixed(fractionalDigits) + \",\"\r\n                + this.m42.toFixed(fractionalDigits) + \",\"\r\n                + this.m43.toFixed(fractionalDigits) + \",\"\r\n                + this.m44.toFixed(fractionalDigits) + \")\";\r\n        }\r\n\r\n        public setCSS(cssString: string): Matrix3D {\r\n            if (!cssString || cssString == \"none\")\r\n                return this.identity();\r\n            var trans: any = cssString.replace(\"matrix3d(\", \"\").replace(\"matrix(\", \"\").replace(\")\", \"\").split(\",\");\r\n            var l = trans.length;\r\n            for (var i = 0; i < l; ++i)\r\n                trans[i] = math.Number.parse(trans[i], 0);\r\n            return this.setData(trans);\r\n        }\r\n\r\n        public appendCSS(cssString: string, force2D: boolean = false): Matrix3D {\r\n            if (!cssString || cssString == \"none\")\r\n                return this;\r\n            if (force2D && cssString.indexOf(\"matrix3d\") >= 0)\r\n                return this.append(Matrix3D._MATRIX3D.setCSS(cssString).flatten());\r\n            return this.append(Matrix3D._MATRIX3D.setCSS(cssString));\r\n        }\r\n\r\n        public prependCSS(cssString: string, force2D: boolean = false): Matrix3D {\r\n            if (!cssString || cssString == \"none\")\r\n                return this;\r\n            if (force2D && cssString.indexOf(\"matrix3d\") >= 0)\r\n                return this.prepend(Matrix3D._MATRIX3D.setCSS(cssString).flatten());\r\n            return this.prepend(Matrix3D._MATRIX3D.setCSS(cssString));\r\n        }\r\n\r\n        public flatten(): Matrix3D {\r\n            this.m31 = 0;\r\n            this.m32 = 0;\r\n            this.m33 = 1;\r\n            this.m34 = 0;\r\n            this.m44 = 1;\r\n            this.m14 = 0;\r\n            this.m24 = 0;\r\n            this.m43 = 0;\r\n            return this;\r\n        }\r\n\r\n        public is2D(): boolean {\r\n            return (this.m31 == 0 && this.m32 == 0 && this.m33 == 1 && this.m34 == 0 && this.m43 == 0 && this.m44 == 1);\r\n        }\r\n\r\n        public is3D(): boolean {\r\n            return !this.is2D();\r\n        }\r\n\r\n        public bounds(x: number, y: number, width: number, height: number, ret = new geom.Rect2D()): geom.Rect2D {\r\n            var ptA = new geom.Point3D(x, y);\r\n            var ptB = new geom.Point3D(x + width, y);\r\n            var ptC = new geom.Point3D(x + width, y + height);\r\n            var ptD = new geom.Point3D(x, y + height);\r\n\r\n            this.project(ptA, ptA);\r\n            this.project(ptB, ptB);\r\n            this.project(ptC, ptC);\r\n            this.project(ptD, ptD);\r\n\r\n            var x = Math.min(ptA.x, ptB.x, ptC.x, ptD.x);\r\n            var y = Math.min(ptA.y, ptB.y, ptC.y, ptD.y);\r\n            var width = Math.max(ptA.x, ptB.x, ptC.x, ptD.x) - x;\r\n            var height = Math.max(ptA.y, ptB.y, ptC.y, ptD.y) - y;\r\n\r\n            return ret.setTo(x, y, width, height);\r\n        }\r\n\r\n        public static multiply(a: IMatrix3DValue, b: IMatrix3DValue, ret: Matrix3D = new Matrix3D()): Matrix3D {\r\n            var m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;\r\n            var m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;\r\n            var m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;\r\n            var m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;\r\n            var m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;\r\n            var m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;\r\n            var m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;\r\n            var m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;\r\n            var m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;\r\n            var m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;\r\n            var m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;\r\n            var m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;\r\n            var m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;\r\n            var m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;\r\n            var m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;\r\n            var m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;\r\n\r\n            ret.m11 = m11;\r\n            ret.m12 = m12;\r\n            ret.m13 = m13;\r\n            ret.m14 = m14;\r\n            ret.m21 = m21;\r\n            ret.m22 = m22;\r\n            ret.m23 = m23;\r\n            ret.m24 = m24;\r\n            ret.m31 = m31;\r\n            ret.m32 = m32;\r\n            ret.m33 = m33;\r\n            ret.m34 = m34;\r\n            ret.m41 = m41;\r\n            ret.m42 = m42;\r\n            ret.m43 = m43;\r\n            ret.m44 = m44;\r\n\r\n            return ret;\r\n        }\r\n\r\n        public toStringTable(fractionalDigits: number = 3): string {\r\n            return \"m11=\" + this.m11.toFixed(fractionalDigits)\r\n                + \"\\tm21=\" + this.m21.toFixed(fractionalDigits)\r\n                + \"\\tm31=\" + this.m31.toFixed(fractionalDigits)\r\n                + \"\\tm41=\" + this.m41.toFixed(fractionalDigits)\r\n                + \"\\nm12=\" + this.m12.toFixed(fractionalDigits)\r\n                + \"\\tm22=\" + this.m22.toFixed(fractionalDigits)\r\n                + \"\\tm32=\" + this.m32.toFixed(fractionalDigits)\r\n                + \"\\tm42=\" + this.m42.toFixed(fractionalDigits)\r\n                + \"\\nm13=\" + this.m13.toFixed(fractionalDigits)\r\n                + \"\\tm23=\" + this.m23.toFixed(fractionalDigits)\r\n                + \"\\tm33=\" + this.m33.toFixed(fractionalDigits)\r\n                + \"\\tm43=\" + this.m43.toFixed(fractionalDigits)\r\n                + \"\\nm14=\" + this.m14.toFixed(fractionalDigits)\r\n                + \"\\tm24=\" + this.m24.toFixed(fractionalDigits)\r\n                + \"\\tm34=\" + this.m34.toFixed(fractionalDigits)\r\n                + \"\\tm44=\" + this.m44.toFixed(fractionalDigits);\r\n        }\r\n\r\n        private static _POINT: Point3D = new Point3D();\r\n        private static _MATRIX3D = new Matrix3D();\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/MatrixFit.ts",
      "size": 8226,
      "sizeMinified": 3070,
      "code": "namespace jsidea.geom {\r\n    /**\r\n    *  \r\n    * @author Jöran Benker\r\n    * \r\n    */\r\n    export class MatrixFit {\r\n        public static quad(from: IQuadValue, to: IQuadValue): Matrix2D {\r\n            var s = MatrixFit.basis(from);\r\n            var d = MatrixFit.basis(to);\r\n            var ad = Matrix2D.adjugate(s);\r\n            return d.append(ad).normalize();\r\n        }\r\n\r\n        public static fromQuad(origin: IPoint2DValue, width: number, height: number, to: IQuadValue): Matrix2D {\r\n            var from = new geom.Quad();\r\n            from.setRect(-origin.x, -origin.y, width, height);\r\n            var m = MatrixFit.quad(from, to);\r\n            m.prependPositionRaw(-origin.x, -origin.y);\r\n            return m;\r\n        }\r\n\r\n        private static basis(quad: IQuadValue): Matrix2D {\r\n            var m = new Matrix2D();\r\n            m.m11 = quad.p1.x;\r\n            m.m12 = quad.p1.y;\r\n            m.m13 = 1;\r\n            m.m21 = quad.p2.x;\r\n            m.m22 = quad.p2.y;\r\n            m.m23 = 1;\r\n            m.m31 = quad.p3.x;\r\n            m.m32 = quad.p3.y;\r\n            m.m33 = 1;\r\n            var adj = Matrix2D.adjugate(m);\r\n            var v = adj.transform(quad.p4);\r\n            var ma = new Matrix2D();\r\n            ma.m11 = v.x;\r\n            ma.m22 = v.y;\r\n            ma.m33 = v.w;\r\n            return m.append(ma);\r\n        }\r\n        \r\n        /**\r\n         * @param from Vector of 2D points in source coordinate system\r\n         * @param to Vector of 2D points in target coordinate system\r\n         * @return A 2D matrix which transform from source to target.\r\n         */\r\n        public static affine2D(from: IPoint2DValue[], to: IPoint2DValue[]): Matrix2D {\r\n            if (from.length != to.length || from.length < 1)\r\n                throw new Error(\"Size missmatch: 'from' and 'to' must be of same size.\");\r\n\r\n            var from_pt: number[][] = []\r\n            var to_pt: number[][] = [];\r\n            var l: number = from.length;\r\n            for (var i: number = 0; i < l; ++i) {\r\n                from_pt.push([from[i].x, from[i].y]);\r\n                to_pt.push([to[i].x, to[i].y]);\r\n            }\r\n\r\n            var sol: number[][] = this.solve(from_pt, to_pt);\r\n            var matrix = new geom.Matrix2D();\r\n            return matrix.setData(\r\n                [//column_0\r\n                    sol[0][0],\r\n                    sol[0][1],\r\n                \r\n                    //column_1\r\n                    sol[1][0],\r\n                    sol[1][1],\r\n                \r\n                    //column_2\r\n                    sol[2][0],\r\n                    sol[2][1]]\r\n            );\r\n        }\r\n        \r\n        /**\r\n         * @param from Vector of 3D points in source coordinate system\r\n         * @param to Vector of 3D points in target coordinate system\r\n         * @return A 3D matrix which transform from source to target.\r\n         */\r\n        public static affine3D(from: IPoint3DValue[], to: IPoint3DValue[]): Matrix3D {\r\n            if (from.length != to.length || from.length < 1)\r\n                throw new Error(\"Size missmatch: 'from' and 'to' must be of same size.\");\r\n\r\n            var from_pt: number[][] = [];\r\n            var to_pt: number[][] = [];\r\n            var l: number = from.length;\r\n            for (var i: number = 0; i < l; ++i) {\r\n                from_pt.push([from[i].x, from[i].y, from[i].z]);\r\n                to_pt.push([to[i].x, to[i].y, to[i].z]);\r\n            }\r\n\r\n            var sol: number[][] = this.solve(from_pt, to_pt);\r\n            var matrix = new geom.Matrix3D();\r\n            return matrix.setData(\r\n                [\r\n                    //column_0\r\n                    sol[0][0],\r\n                    sol[0][1],\r\n                    sol[0][2],\r\n                    0,\r\n                    \r\n                    //column_1\r\n                    sol[1][0],\r\n                    sol[1][1],\r\n                    sol[1][2],\r\n                    0,\r\n                    \r\n                    //column_2\r\n                    sol[2][0],\r\n                    sol[2][1],\r\n                    sol[2][2],\r\n                    0,\r\n                    \r\n                    //column_3\r\n                    sol[3][0],\r\n                    sol[3][1],\r\n                    sol[3][2],\r\n                    1\r\n                ]);\r\n        }\r\n        \r\n        /**\r\n         * Based on \"Fit an affine transformation to given points\", by Jarno Elonen (2007)\r\n         * http://elonen.iki.fi/code/misc-notes/affine-fit/.\r\n         * That code based on the paper \"Fitting affine and orthogonal transformations\r\n         * between two sets of points\" by Helmuth Späth (2003).\r\n         * \r\n         * Its ordered by columns. To access an entry use this format 'matrix[column_index][row_index]'.\r\n         * @param from Vector of N-dimensional points in source coordinate system\r\n         * @param to Vector of N-dimensional points in target coordinate system\r\n         * @return A reduced (N+1)x(N) matrix which transform N-dimensional vectors from source to target.\r\n         */\r\n        private static solve(from: number[][], to: number[][]): number[][] {\r\n            //check pre-conditions\r\n            if (from.length != to.length || from.length < 1)\r\n                throw new Error(\"Size missmatch: 'from' and 'to' must be of same size.\");\r\n            if (from[0].length != to[0].length)\r\n                throw new Error(\"Dimension missmatch: 'from' has the dimension \" + from[0].length + \" and 'to' \" + to[0].length + \".\");\r\n            if (from.length < from[0].length + 1)\r\n                throw new Error(\"Too few points: under-determined system, you need \" + (from[0].length + 1 - from.length) + \" more reference points for a 'overconstrained' system.\");\r\n            \r\n            //the dimensions to solve (point: 2, vector3D: 3, ...)\r\n            var dim: number = from[0].length;\r\n            \r\n            //re-usable variables\r\n            var i: number;\r\n            var j: number;\r\n            var k: number;\r\n            var e: number[];\r\n            \r\n            //create \"acc\": empty (N)x(N+1) matrix\r\n            var acc: number[][] = [];\r\n            for (i = 0; i < dim + 1; ++i) {\r\n                acc[i] = [];\r\n                for (j = 0; j < dim; ++j)\r\n                    acc[i][j] = 0;\r\n            }\r\n            \r\n            //fill \"acc\" matrix\r\n            for (i = 0; i < dim + 1; ++i)\r\n                for (j = 0; j < dim; ++j)\r\n                    for (k = 0; k < from.length; ++k) {\r\n                        e = from[k].slice();\r\n                        e.push(1);\r\n                        acc[i][j] += e[i] * to[k][j];\r\n                    }   \r\n            \r\n            //create \"Q\": empty (N+1)x(N+1) matrix\r\n            var Q: number[][] = [];\r\n            for (i = 0; i < dim + 1; ++i) {\r\n                Q[i] = [];\r\n                for (j = 0; j < dim + 1; ++j)\r\n                    Q[i][j] = 0;\r\n            }\r\n            \r\n            //fill \"Q\" matrix\r\n            for (k = 0; k < from.length; ++k) {\r\n                e = from[k].slice();\r\n                e.push(1);\r\n                for (i = 0; i < dim + 1; ++i)\r\n                    for (j = 0; j < dim + 1; ++j)\r\n                        Q[i][j] += e[i] * e[j];\r\n            }\r\n            \r\n            //concat \"Q\" with \"acc\" by each entry pair\r\n            var matrix: number[][] = [];\r\n            for (i = 0; i < dim + 1; ++i) {\r\n                matrix[i] = Q[i].slice();\r\n                for (j = 0; j < dim; ++j)\r\n                    matrix[i].push(acc[i][j]);\r\n            }\r\n            \r\n            //solve Q * a' = acc with by Gauss-Jordan\r\n            var solved: Boolean = this.gaussJordan(matrix);\r\n            if (!solved)\r\n                throw new Error(\"Could not solve affine transformation. Singular matrix: points are probably coplanar.\");\r\n            \r\n            //remove unnecessary entries\r\n            var l: number = matrix.length;\r\n            var off: number = matrix[0].length - dim;\r\n            for (i = 0; i < l; ++i)\r\n                matrix[i] = matrix[i].slice(off);\r\n\r\n            return matrix;\r\n        }\r\n        \r\n        /**\r\n         * Transforms a N-dimensional vector to a N-dimensional vector using the given matrix.\r\n         * @param matrix A (N+1)x(N) matrix to tranform a vector.\r\n         * @param vector A N-dimensional vector. \r\n         * @param result A pointer for the result to write in.\r\n         * @return The transformed vector.         * \r\n         */\r\n        private static transform(\r\n            matrix: number[][],\r\n            vector: number[],\r\n            result: number[] = null): number[] {\r\n            var dim: number = vector.length;\r\n            result = result || [];\r\n            for (var i: number = 0; i < dim; ++i)\r\n                result[i] = 0;\r\n            for (i = 0; i < dim; ++i) {\r\n                for (var j: number = 0; j < dim; ++j)\r\n                    result[i] += vector[j] * matrix[j][i];\r\n                result[i] += matrix[dim][i]\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private static gaussJordan(matrix: number[][]): Boolean {\r\n            //re-usable index variables\r\n            var i: number;\r\n            var j: number;\r\n            var k: number\r\n\r\n            var h: number = matrix.length;\r\n            var w: number = matrix[0].length;\r\n            for (i = 0; i < h - 1; ++i) {\r\n                //find max pivot\r\n                var maxrow: number = i;\r\n                for (j = i + 1; j < h; ++j)\r\n                    if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxrow][i]))\r\n                        maxrow = j;\r\n                \r\n                //swap...?\r\n                var tmp: number[] = matrix[maxrow];\r\n                matrix[maxrow] = matrix[i];\r\n                matrix[i] = tmp;\r\n                \r\n                //if singular return false\r\n                if (Math.abs(matrix[i][i]) <= 1e-10)\r\n                    return false;\r\n                \r\n                //eliminate column y\r\n                for (j = i + 1; j < h; ++j) {\r\n                    var c: number = matrix[j][i] / matrix[i][i];\r\n                    for (k = i; k < w; ++k)\r\n                        matrix[j][k] -= matrix[i][k] * c;\r\n                }\r\n            }\r\n            \r\n            //backsubstitute\r\n            for (i = h - 1; i >= 0; --i) {\r\n                c = matrix[i][i];\r\n                for (j = 0; j < i; ++j)\r\n                    for (k = w - 1; k >= i; --k)\r\n                        matrix[j][k] -= matrix[i][k] * matrix[j][i] / c;\r\n                matrix[i][i] /= c;\r\n                //normalize row y\r\n                for (k = h; k < w; ++k)\r\n                    matrix[i][k] /= c;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/MatrixUtil.ts",
      "size": 1435,
      "sizeMinified": 565,
      "code": "namespace jsidea.geom {\r\n    /**\r\n    *  \r\n    * @author Jöran Benker\r\n    * \r\n    */\r\n    export class MatrixUtil {\r\n        private static tempAxeX: Point3D = new Point3D();\r\n        private static tempAxeY: Point3D = new Point3D();\r\n        private static tempAxeZ: Point3D = new Point3D();\r\n\r\n        public static lookAt(eye: Point3D, target: Point3D, up: Point3D): Matrix3D {\r\n            var x: Point3D = MatrixUtil.tempAxeX;\r\n            var y: Point3D = MatrixUtil.tempAxeY;\r\n            var z: Point3D = MatrixUtil.tempAxeZ;\r\n\r\n            z.difference(eye, target).normalize();\r\n            if (z.length() === 0) {\r\n                z.z = 1;\r\n            }\r\n            x.crossSet(up, z).normalize();\r\n            if (x.length() === 0) {\r\n                z.x += 0.0001;\r\n                x.crossSet(up, z).normalize();\r\n            }\r\n            y.crossSet(z, x);\r\n\r\n            var m = new Matrix3D();\r\n            m.m11 = x.x;\r\n            m.m12 = x.y;\r\n            m.m13 = x.z;\r\n            m.m21 = y.x;\r\n            m.m22 = y.y;\r\n            m.m23 = y.z;\r\n            m.m31 = z.x;\r\n            m.m32 = z.y;\r\n            m.m33 = z.z;\r\n            return m;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/Point2D.ts",
      "size": 7559,
      "sizeMinified": 2882,
      "code": "namespace jsidea.geom {\r\n    export class Point2D implements IPoint2DValue {\r\n\r\n        public static X_AXIS: Point2D = new Point2D(1, 0);\r\n        public static Y_AXIS: Point2D = new Point2D(0, 1);\r\n\r\n        constructor(\r\n            public x: number = 0,\r\n            public y: number = 0,\r\n            public w: number = 1) {\r\n        }\r\n\r\n        public static create(\r\n            x: number = 0,\r\n            y: number = 0,\r\n            w: number = 1): Point2D {\r\n            return new Point2D(x, y, w);\r\n        }\r\n\r\n        public getData(length: number = 2): number[] {\r\n            if (length > 2)\r\n                return [this.x, this.y, this.w];\r\n            return [this.x, this.y];\r\n        }\r\n\r\n        public setData(data: number[], offset: number = 0, length: number = 2): Point2D {\r\n            if (data === undefined)\r\n                return;\r\n            this.x = data[0 + offset];\r\n            this.y = data[1 + offset];\r\n            if (length > 2)\r\n                this.w = data[2 + offset];\r\n            return this;\r\n        }\r\n        \r\n        public setTo(x: number, y: number, w: number = 1): Point2D {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.w = w;\r\n            return this;\r\n        }\r\n\r\n        public copyFrom(pt: IPoint2DValue): Point2D {\r\n            this.x = pt.x;\r\n            this.y = pt.y;\r\n            this.w = pt.w === undefined ? 1 : pt.w;\r\n            return this;\r\n        }\r\n\r\n        public copyTo(target: IPoint2DValue): Point2D {\r\n            target.x = this.x;\r\n            target.y = this.y;\r\n            if (target.w !== undefined)\r\n                target.w = this.w;\r\n            return this;\r\n        }\r\n\r\n        public equals(point: IPoint2DValue): boolean {\r\n            return point.x == this.x && point.y == this.y && this.w == (point.w === undefined ? 1 : point.w);\r\n        }\r\n\r\n        public length(): number {\r\n            return Math.sqrt(this.x * this.x + this.y * this.y);\r\n        }\r\n\r\n        public normalize(length: number = 1): Point2D {\r\n            var len: number = this.length();\r\n            if (!len)\r\n                return;\r\n            this.scalar(length / len);\r\n        }\r\n\r\n        public clamp(length: number): Point2D {\r\n            var len: number = this.length();\r\n            if (!len || len <= length)\r\n                return;\r\n            this.scalar(length / len);\r\n        }\r\n\r\n        public scalar(scale: number): Point2D {\r\n            this.x *= scale;\r\n            this.y *= scale;\r\n            return this;\r\n        }\r\n\r\n        public mul(pt: IPoint2DValue): Point2D {\r\n            this.x *= pt.x;\r\n            this.y *= pt.y;\r\n            return this;\r\n        }\r\n\r\n        public product(factorA: IPoint2DValue, factorB: IPoint2DValue): Point2D {\r\n            this.x = factorA.x * factorB.x;\r\n            this.y = factorA.y * factorB.y;\r\n            return this;\r\n        }\r\n\r\n        public div(pt: IPoint2DValue): Point2D {\r\n            this.x /= pt.x;\r\n            this.y /= pt.y;\r\n            return this;\r\n        }\r\n\r\n        public quotient(divident: IPoint2DValue, divisor: IPoint2DValue): Point2D {\r\n            this.x = divident.x / divisor.x;\r\n            this.y = divident.y / divisor.y;\r\n            return this;\r\n        }\r\n\r\n        public dot(pt: IPoint2DValue): number {\r\n            return this.x * pt.x + this.y * pt.y;\r\n        }\r\n\r\n        public add(pt: IPoint2DValue): Point2D {\r\n            this.x += pt.x;\r\n            this.y += pt.y;\r\n            return this;\r\n        }\r\n\r\n        public translate(x: number, y: number): Point2D {\r\n            this.x += x;\r\n            this.y += y;\r\n            return this;\r\n        }\r\n\r\n        public sum(sumA: IPoint2DValue, sumB: IPoint2DValue): Point2D {\r\n            this.x = sumA.x + sumB.x;\r\n            this.y = sumA.y + sumB.y;\r\n            return this;\r\n        }\r\n\r\n        public sub(pt: IPoint2DValue): Point2D {\r\n            this.x -= pt.x;\r\n            this.y -= pt.y;\r\n            return this;\r\n        }\r\n\r\n        public difference(minuend: IPoint2DValue, subtrahend: IPoint2DValue): Point2D {\r\n            this.x = minuend.x - subtrahend.x;\r\n            this.y = minuend.y - subtrahend.y;\r\n            return this;\r\n        }\r\n\r\n        public clone(): Point2D {\r\n            return new Point2D(this.x, this.y);\r\n        }\r\n\r\n        public cross(pt: IPoint2DValue): Point2D {\r\n            var x = this.x;\r\n            var y = this.y;\r\n            this.x = y * pt.x - x * pt.y;\r\n            this.y = x * pt.y - y * pt.x;\r\n            return this;\r\n        }\r\n\r\n        public static interpolate(v0: IPoint2DValue, v1: IPoint2DValue, f: number, ret: Point2D = new Point2D()): Point2D {\r\n            return ret.setTo(\r\n                v0.x + (v1.x - v0.x) * f,\r\n                v0.y + (v1.y - v0.y) * f);\r\n        }\r\n\r\n        public static polar(angle: number, length: number, ret: Point2D = new Point2D()): Point2D {\r\n            var angRad = angle * math.Number.DEG_TO_RAD;\r\n            return ret.setTo(Math.cos(angRad) * length, Math.sin(angRad) * length);\r\n        }\r\n\r\n        public static distance(v0: IPoint2DValue, v1: IPoint2DValue): number {\r\n            var dx: number = v0.x - v1.x;\r\n            var dy: number = v0.y - v1.y;\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        }\r\n\r\n        public static reflect(direction: IPoint2DValue, normal: IPoint2DValue, ret: Point2D = new Point2D()): Point2D {\r\n            var dp: number = direction.x * normal.x + direction.y * normal.y;\r\n            return ret.setTo(direction.x - 2 * dp * normal.x, direction.y - 2 * dp * normal.y);\r\n        }\r\n\r\n        public static intersection(p1: IPoint2DValue, p2: IPoint2DValue, p3: IPoint2DValue, p4: IPoint2DValue, ret: Point2D = new Point2D()): Point2D {\r\n            var x1: number = p1.x;\r\n            var y1: number = p1.y;\r\n            var x4: number = p4.x;\r\n            var y4: number = p4.y;\r\n\r\n            var dx1: number = p2.x - x1;\r\n            var dx2: number = p3.x - x4;\r\n\r\n            if (!dx1 && !dx2)\r\n                return null;\r\n\r\n            var m1: number = (p2.y - y1) / dx1;\r\n            var m2: number = (p3.y - y4) / dx2;\r\n\r\n            if (!dx1)\r\n                return ret.setTo(x1, m2 * (x1 - x4) + y4);// infinity\r\n            else if (!dx2)\r\n                return ret.setTo(x4, m1 * (x4 - x1) + y1);// infinity\r\n            \r\n            var xInt: number = (-m2 * x4 + y4 + m1 * x1 - y1) / (m1 - m2);\r\n            var yInt: number = m1 * (xInt - x1) + y1;\r\n            if (isNaN(xInt) || isNaN(yInt))\r\n                return null;\r\n            return ret.setTo(xInt, yInt);\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/Point3D.ts",
      "size": 7680,
      "sizeMinified": 2916,
      "code": "namespace jsidea.geom {\r\n    export class Point3D implements IPoint3DValue {\r\n\r\n        public static X_AXIS: Point3D = new Point3D(1, 0, 0);\r\n        public static Y_AXIS: Point3D = new Point3D(0, 1, 0);\r\n        public static Z_AXIS: Point3D = new Point3D(0, 0, 1);\r\n\r\n        constructor(\r\n            public x: number = 0,\r\n            public y: number = 0,\r\n            public z: number = 0,\r\n            public w: number = 1) {\r\n        }\r\n\r\n        public static create(\r\n            x: number = 0,\r\n            y: number = 0,\r\n            z: number = 0,\r\n            w: number = 1): Point3D {\r\n            return new Point3D(x, y, z, w);\r\n        }\r\n\r\n        public getData(): number[] {\r\n            return [this.x, this.y, this.z];\r\n        }\r\n\r\n        public setData(data: number[], offset: number = 0): Point3D {\r\n            if (data === undefined)\r\n                return;\r\n            this.x = data[0 + offset];\r\n            this.y = data[1 + offset];\r\n            this.z = data[2 + offset];\r\n            this.w = data.length > (3 + offset) ? data[3 + offset] : 1;\r\n        }\r\n\r\n        public copyFrom(pt: IPoint3DValue): Point3D {\r\n            this.x = pt.x;\r\n            this.y = pt.y;\r\n            this.z = pt.z;\r\n            this.w = pt.w;\r\n            return this;\r\n        }\r\n\r\n        public copyTo(target: IPoint3DValue): Point3D {\r\n            target.x = this.x;\r\n            target.y = this.y;\r\n            target.z = this.z;\r\n            target.w = this.w;\r\n            return this;\r\n        }\r\n\r\n        public equals(point: IPoint3DValue): boolean {\r\n            return point.x == this.x && point.y == this.y && point.z == this.z;\r\n        }\r\n\r\n        public length(): number {\r\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n        }\r\n\r\n        public normalize(length: number = 1): Point3D {\r\n            var len: number = this.length();\r\n            if (!len)\r\n                return;\r\n            this.scalar(length / len);\r\n        }\r\n\r\n        public clamp(length: number): Point3D {\r\n            var len: number = this.length();\r\n            if (!len || len <= length)\r\n                return;\r\n            this.scalar(length / len);\r\n        }\r\n\r\n        public scalar(scale: number): Point3D {\r\n            this.x *= scale;\r\n            this.y *= scale;\r\n            this.z *= scale;\r\n            return this;\r\n        }\r\n\r\n        public setTo(x: number, y: number, z: number, w: number = 1): Point3D {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n            this.w = w;\r\n            return this;\r\n        }\r\n\r\n        public cross(pt: IPoint3DValue): Point3D {\r\n            var x = this.x;\r\n            var y = this.y;\r\n            var z = this.z;\r\n            this.x = y * pt.z - z * pt.y;\r\n            this.y = z * pt.x - x * pt.z;\r\n            this.z = x * pt.y - y * pt.x;\r\n            return this;\r\n        }\r\n\r\n        public crossSet(a: IPoint3DValue, b: IPoint3DValue): Point3D {\r\n            var ax = a.x;\r\n            var ay = a.y;\r\n            var az = a.z;\r\n            var bx = b.x;\r\n            var by = b.y;\r\n            var bz = b.z;\r\n            this.x = ay * bz - az * by;\r\n            this.y = az * bx - ax * bz;\r\n            this.z = ax * by - ay * bx;\r\n            return this;\r\n        }\r\n\r\n        public mul(pt: IPoint3DValue): Point3D {\r\n            this.x *= pt.x;\r\n            this.y *= pt.y;\r\n            this.z *= pt.z;\r\n            return this;\r\n        }\r\n\r\n        public product(factorA: IPoint3DValue, factorB: IPoint3DValue): Point3D {\r\n            this.x = factorA.x * factorB.x;\r\n            this.y = factorA.y * factorB.y;\r\n            this.z = factorA.z * factorB.z;\r\n            return this;\r\n        }\r\n\r\n        public div(divisor: IPoint3DValue): Point3D {\r\n            this.x /= divisor.x;\r\n            this.y /= divisor.y;\r\n            this.z /= divisor.z;\r\n            return this;\r\n        }\r\n\r\n        public quotient(divident: IPoint3DValue, divisor: IPoint3DValue): Point3D {\r\n            this.x = divident.x / divisor.x;\r\n            this.y = divident.y / divisor.y;\r\n            this.z = divident.z / divisor.z;\r\n            return this;\r\n        }\r\n\r\n        public dot(pt: IPoint3DValue): number {\r\n            return this.x * pt.x + this.y * pt.y + this.z * pt.z;\r\n        }\r\n\r\n        public add(summand: IPoint3DValue): Point3D {\r\n            this.x += summand.x;\r\n            this.y += summand.y;\r\n            this.z += summand.z;\r\n            return this;\r\n        }\r\n        \r\n        public translate(x: number, y: number, z: number): Point3D {\r\n            this.x += x;\r\n            this.y += y;\r\n            this.z += z;\r\n            return this;\r\n        }\r\n\r\n        public sum(summandA: IPoint3DValue, summandB: IPoint3DValue): Point3D {\r\n            this.x = summandA.x + summandB.x;\r\n            this.y = summandA.y + summandB.y;\r\n            this.z = summandA.z + summandB.z;\r\n            return this;\r\n        }\r\n\r\n        public sub(subtrahend: IPoint3DValue): Point3D {\r\n            this.x -= subtrahend.x;\r\n            this.y -= subtrahend.y;\r\n            this.z -= subtrahend.z;\r\n            return this;\r\n        }\r\n\r\n        public difference(minuend: IPoint3DValue, subtrahend: IPoint3DValue): Point3D {\r\n            this.x = minuend.x - subtrahend.x;\r\n            this.y = minuend.y - subtrahend.y;\r\n            this.z = minuend.z - subtrahend.z;\r\n            return this;\r\n        }\r\n\r\n        public clone(): Point3D {\r\n            return new Point3D(this.x, this.y, this.z, this.w);\r\n        }\r\n\r\n        public static interpolate(v0: IPoint3DValue, v1: IPoint3DValue, f: number): Point3D {\r\n            return new Point3D(\r\n                v0.x + (v1.x - v0.x) * f,\r\n                v0.y + (v1.y - v0.y) * f,\r\n                v0.z + (v1.z - v0.z) * f);\r\n        }\r\n\r\n        //TODO: implement it\r\n        public static polar(angle: IPoint3DValue, length: number, ret: Point3D = new Point3D()): Point3D {\r\n            var angRad = angle.x * math.Number.DEG_TO_RAD;\r\n            ret.x = Math.cos(angRad) * length;\r\n            ret.y = Math.sin(angRad) * length;\r\n            return ret;\r\n        }\r\n\r\n        public static distance(v0: IPoint3DValue, v1: IPoint3DValue): number {\r\n            var dx: number = v0.x - v1.x;\r\n            var dy: number = v0.y - v1.y;\r\n            var dz: number = v0.z - v1.z;\r\n            return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n        }\r\n\r\n        public static reflect(vector: IPoint3DValue, normal: IPoint3DValue): Point3D {\r\n            var dp: number = vector.x * normal.x + vector.y * normal.y + vector.z * normal.z;\r\n            return new Point3D(vector.x - 2 * dp * normal.x, vector.y - 2 * dp * normal.y, vector.z - 2 * dp * normal.z);\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/Quad.ts",
      "size": 2143,
      "sizeMinified": 1003,
      "code": "namespace jsidea.geom {\r\n    export class Quad implements IQuadValue {\r\n        public points: geom.Point3D[] = [];\r\n        constructor(\r\n            public p1: geom.Point3D = new geom.Point3D(),\r\n            public p2: geom.Point3D = new geom.Point3D(),\r\n            public p3: geom.Point3D = new geom.Point3D(),\r\n            public p4: geom.Point3D = new geom.Point3D()\r\n        ) {\r\n            this.points = [this.p1, this.p2, this.p3, this.p4];\r\n        }\r\n\r\n        public clone(): Quad {\r\n            return new Quad(\r\n                this.p1.clone(),\r\n                this.p2.clone(),\r\n                this.p3.clone(),\r\n                this.p4.clone());\r\n        }\r\n\r\n        public setRect(x: number, y: number, width: number, height: number): Quad {\r\n            this.p1.x = x;\r\n            this.p1.y = y;\r\n            this.p2.x = x + width;\r\n            this.p2.y = y;\r\n            this.p3.x = x;\r\n            this.p3.y = y + height;\r\n            this.p4.x = x + width;\r\n            this.p4.y = y + height;\r\n            return this;\r\n        }\r\n\r\n        public setData(\r\n            data: IPoint3DValue[]): Quad {\r\n            this.p1.copyFrom(data[0]);\r\n            this.p2.copyFrom(data[1]);\r\n            this.p3.copyFrom(data[2]);\r\n            this.p4.copyFrom(data[3]);\r\n            return this;\r\n        }\r\n\r\n        public setTo(\r\n            p1: geom.IPoint3DValue,\r\n            p2: geom.IPoint3DValue,\r\n            p3: geom.IPoint3DValue,\r\n            p4: geom.IPoint3DValue): Quad {\r\n            this.p1.copyFrom(p1);\r\n            this.p2.copyFrom(p2);\r\n            this.p3.copyFrom(p3);\r\n            this.p4.copyFrom(p4);\r\n            return this;\r\n        }\r\n\r\n        public copyFrom(value: IQuadValue): Quad {\r\n            return this.setTo(value.p1, value.p2, value.p3, value.p4);\r\n        }\r\n\r\n        public dispose(): void {\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/geom/Rect2D.ts",
      "size": 6903,
      "sizeMinified": 3043,
      "code": "namespace jsidea.geom {\r\n    export class Rect2D implements IRect2DValue {\r\n        constructor(\r\n            public x: number = 0,\r\n            public y: number = 0,\r\n            public width: number = 0,\r\n            public height: number = 0) {\r\n        }\r\n\r\n        public clone(): Rect2D {\r\n            return new Rect2D(\r\n                this.x,\r\n                this.y,\r\n                this.width,\r\n                this.height);\r\n        }\r\n\r\n        public setTo(x: number, y: number, width: number, height: number): Rect2D {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.width = width;\r\n            this.height = height;\r\n\r\n            return this;\r\n        }\r\n\r\n        public toQuad(ret: Quad = new Quad()): Quad {\r\n            ret.p1.x = this.x;\r\n            ret.p1.y = this.y;\r\n            ret.p2.x = this.right;\r\n            ret.p2.y = this.y;\r\n            ret.p3.x = this.right;\r\n            ret.p3.y = this.bottom;\r\n            ret.p4.x = this.x;\r\n            ret.p4.y = this.bottom;\r\n            return ret;\r\n        }\r\n\r\n        public setCSS(clipCSS: string): Rect2D {\r\n            if (!clipCSS || clipCSS == \"auto\")\r\n                return this;\r\n            //TODO: using a regex -> performance testing\r\n            var str = clipCSS.toLowerCase().replace(\"rect(\", \"\").replace(\")\", \"\");\r\n            var values = system.Engine.isWebKit ? str.split(\" \") : str.split(\",\");\r\n\r\n            this.x = math.Number.parse(values[3], 0);\r\n            this.y = math.Number.parse(values[0], 0);\r\n            this.width = math.Number.parse(values[1], 0) - this.x;\r\n            this.height = math.Number.parse(values[2], 0) - this.y;\r\n\r\n            return this;\r\n        }\r\n\r\n        public getCSS(): string {\r\n            return \"rect(\"\r\n                + Math.round(this.y) + \"px, \"\r\n                + Math.round(this.right) + \"px, \"\r\n                + Math.round(this.bottom) + \"px, \"\r\n                + Math.round(this.x) + \"px)\";\r\n        }\r\n\r\n        public copyFrom(value: IRect2DValue): void {\r\n            this.x = value.x;\r\n            this.y = value.y;\r\n            this.width = value.width;\r\n            this.height = value.height;\r\n        }\r\n\r\n        public center(ret: geom.Point2D = new geom.Point2D()): geom.Point2D {\r\n            return ret.setTo(this.x + this.width * 0.5, this.y + this.width * 0.5);\r\n        }\r\n\r\n        public equals(value: IRect2DValue, difference: number = 0): boolean {\r\n            return Math.abs(this.x - value.x) <= difference\r\n                && Math.abs(this.y - value.y) <= difference\r\n                && Math.abs(this.width - value.width) <= difference\r\n                && Math.abs(this.height - value.height) <= difference;\r\n        }\r\n\r\n        public contains(x: number, y: number): boolean {\r\n            return x >= this.x\r\n                && x <= (this.x + this.width)\r\n                && y >= this.y\r\n                && y <= (this.y + this.height);\r\n        }\r\n\r\n        public containsRect(r: IRect2DValue): boolean {\r\n            if (!this.contains(r.x, r.y)\r\n                || !this.contains(r.x + r.width, r.y + r.height)\r\n                || !this.contains(r.x + r.width, r.y)\r\n                || !this.contains(r.x, r.y + r.height)\r\n            )\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public intersects(r: IRect2DValue): boolean {\r\n            if (this.contains(r.x, r.y)\r\n                || this.contains(r.x + r.width, r.y + r.height)\r\n                || this.contains(r.x + r.width, r.y)\r\n                || this.contains(r.x, r.y + r.height)\r\n            )\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        public copyFromClientRect(rect: ClientRect): Rect2D {\r\n            this.x = rect.left;\r\n            this.y = rect.top;\r\n            this.width = rect.width;\r\n            this.height = rect.height;\r\n            return this;\r\n        }\r\n\r\n        public get right(): number {\r\n            return this.x + this.width;\r\n        }\r\n\r\n        public set right(value: number) {\r\n            this.width = value - this.x;\r\n        }\r\n\r\n        public get bottom(): number {\r\n            return this.y + this.height;\r\n        }\r\n\r\n        public set bottom(value: number) {\r\n            this.height = value - this.y;\r\n        }\r\n\r\n        public static getBounds(element: HTMLElement, ret: Rect2D = new Rect2D()): Rect2D {\r\n            ret.copyFromClientRect(element.getBoundingClientRect());\r\n            if (system.Engine.isWebKit) {\r\n                //                var style = layout.Style.create(element);\r\n                //                if (style.transformStyle == \"preserve-3d\" && style.transform.indexOf(\"matrix3d\") >= 0) {\r\n                //                    var mat = geom.Matrix3D.create(element, style);\r\n                //                    var bnd = mat.bounds(0, 0, element.offsetWidth, element.offsetHeight);\r\n                //                    var pt = mat.transformRaw(element.offsetWidth, element.offsetHeight, 0);\r\n                ////                    console.log(element.clientLeft, element.offsetWidth, bnd.toString());\r\n                ////                    console.log(element.offsetWidth - bnd.width);\r\n                ////                    console.log(element.offsetHeight - bnd.height);\r\n                //                    console.log(bnd.width, bnd.height, ret.width, ret.height);\r\n                //                    ret.x -= bnd.width - ret.width;\r\n                //                    ret.y -= bnd.height - ret.height;\r\n                ////                    ret.width = bnd.width;\r\n                ////                    ret.height = bnd.height;\r\n                //                }\r\n\r\n                ret.x += document.body.scrollLeft;\r\n                ret.y += document.body.scrollTop;\r\n            }\r\n            else {\r\n                ret.x += document.documentElement.scrollLeft;\r\n                ret.y += document.documentElement.scrollTop;\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        public static getClip(element: HTMLElement, style: CSSStyleDeclaration, ret: geom.Rect2D = new geom.Rect2D()): geom.Rect2D {\r\n            if (!style.clip || style.clip == \"auto\") {\r\n                ret.x = 0;\r\n                ret.y = 0;\r\n                ret.width = element.offsetWidth;\r\n                ret.height = element.offsetHeight;\r\n                return ret;\r\n            }\r\n            ret.setCSS(style.clip);\r\n            return ret;\r\n        }\r\n\r\n        public dispose(): void {\r\n        }\r\n\r\n        public toString(): string {\r\n            return \"[ jsidea.geom.Box2D\"\r\n                + \" x=\" + this.x\r\n                + \" y=\" + this.y\r\n                + \" width=\" + this.width\r\n                + \" height=\" + this.height\r\n                + \"]\";\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/Box.ts",
      "size": 8432,
      "sizeMinified": 4157,
      "code": "namespace jsidea.layout {\r\n    export class Box {\r\n\r\n        public element: HTMLElement = null;\r\n        public style: CSSStyleDeclaration;\r\n\r\n        public offsetWidth: number = 0;\r\n        public offsetHeight: number = 0;\r\n        public parentWidth: number = 0;\r\n        public parentHeight: number = 0;\r\n\r\n        public marginTop: number = 0;\r\n        public marginRight: number = 0;\r\n        public marginBottom: number = 0;\r\n        public marginLeft: number = 0;\r\n\r\n        public borderTop: number = 0;\r\n        public borderRight: number = 0;\r\n        public borderBottom: number = 0;\r\n        public borderLeft: number = 0;\r\n\r\n        public paddingTop: number = 0;\r\n        public paddingRight: number = 0;\r\n        public paddingBottom: number = 0;\r\n        public paddingLeft: number = 0;\r\n\r\n        public scrollLeft: number = 0;\r\n        public scrollTop: number = 0;\r\n\r\n        constructor(element?: HTMLElement, style?: CSSStyleDeclaration) {\r\n            if (element)\r\n                this.update(element, style);\r\n        }\r\n\r\n        public static create(element?: HTMLElement, style?: CSSStyleDeclaration): Box {\r\n            return new Box(element, style);\r\n        }\r\n\r\n        public update(element: HTMLElement, style?: CSSStyleDeclaration): Box {\r\n            if (!element)\r\n                return this.clear();\r\n            style = style || window.getComputedStyle(element);\r\n\r\n            this.style = style;\r\n            this.element = element;\r\n\r\n            this.offsetWidth = element.offsetWidth;\r\n            this.offsetHeight = element.offsetHeight;\r\n            this.scrollLeft = element.scrollLeft;\r\n            this.scrollTop = element.scrollTop;\r\n\r\n            if (system.Engine.isWebKit) {\r\n                if (element == element.ownerDocument.body) {\r\n                    this.scrollLeft = 0;\r\n                    this.scrollTop = 0;\r\n                }\r\n                else if (system.Engine.isWebKit && element == element.ownerDocument.documentElement) {\r\n                    this.scrollLeft = element.ownerDocument.body.scrollLeft;\r\n                    this.scrollTop = element.ownerDocument.body.scrollTop;\r\n                }\r\n            }\r\n\r\n            if (element.parentElement) {\r\n                this.parentWidth = element.parentElement.clientWidth;\r\n                this.parentHeight = element.parentElement.clientHeight;\r\n            }\r\n            else {\r\n                this.parentWidth = window.innerWidth;\r\n                this.parentHeight = window.innerHeight;\r\n            }\r\n\r\n            var w = this.parentWidth;\r\n            var h = this.parentHeight;\r\n            this.marginTop = math.Number.relation(style.marginTop, h, 0);\r\n            this.marginRight = math.Number.relation(style.marginRight, w, 0);\r\n            this.marginBottom = math.Number.relation(style.marginBottom, h, 0);\r\n            this.marginLeft = math.Number.relation(style.marginLeft, w, 0);\r\n\r\n            this.paddingTop = math.Number.relation(style.paddingTop, h, 0);\r\n            this.paddingRight = math.Number.relation(style.paddingRight, w, 0);\r\n            this.paddingBottom = math.Number.relation(style.paddingBottom, h, 0);\r\n            this.paddingLeft = math.Number.relation(style.paddingLeft, w, 0);\r\n\r\n            this.borderTop = math.Number.parse(style.borderTopWidth, 0);\r\n            this.borderRight = math.Number.parse(style.borderRightWidth, 0);\r\n            this.borderBottom = math.Number.parse(style.borderBottomWidth, 0);\r\n            this.borderLeft = math.Number.parse(style.borderLeftWidth, 0);\r\n\r\n            return this;\r\n        }\r\n\r\n        public copyFrom(size: Box): Box {\r\n            this.element = size.element;\r\n            this.style = size.style;\r\n            this.offsetWidth = size.offsetWidth;\r\n            this.offsetHeight = size.offsetHeight;\r\n            this.parentWidth = size.parentWidth;\r\n            this.parentHeight = size.parentHeight;\r\n\r\n            this.marginTop = size.marginTop;\r\n            this.marginRight = size.marginRight;\r\n            this.marginBottom = size.marginBottom;\r\n            this.marginLeft = size.marginLeft;\r\n\r\n            this.paddingTop = size.paddingTop;\r\n            this.paddingRight = size.paddingRight;\r\n            this.paddingBottom = size.paddingBottom;\r\n            this.paddingLeft = size.paddingLeft;\r\n\r\n            this.borderTop = size.borderTop;\r\n            this.borderRight = size.borderRight;\r\n            this.borderBottom = size.borderBottom;\r\n            this.borderLeft = size.borderLeft;\r\n\r\n            return this;\r\n        }\r\n\r\n        public clone(): Box {\r\n            return (new Box()).copyFrom(this);\r\n        }\r\n\r\n        public clear(): Box {\r\n            this.element = null;\r\n            this.style = null;\r\n\r\n            this.scrollLeft = 0;\r\n            this.scrollTop = 0;\r\n\r\n            this.offsetWidth = 0;\r\n            this.offsetHeight = 0;\r\n            this.parentWidth = 0;\r\n            this.parentHeight = 0;\r\n\r\n            this.marginTop = 0;\r\n            this.marginRight = 0;\r\n            this.marginBottom = 0;\r\n            this.marginLeft = 0;\r\n\r\n            this.paddingTop = 0;\r\n            this.paddingRight = 0;\r\n            this.paddingBottom = 0;\r\n            this.paddingLeft = 0;\r\n\r\n            this.borderTop = 0;\r\n            this.borderRight = 0;\r\n            this.borderBottom = 0;\r\n            this.borderLeft = 0;\r\n\r\n            return this;\r\n        }\r\n\r\n        public apply(element: HTMLElement): Box {\r\n            var style = element.style;\r\n            //TODO:\r\n            //keep units here (percentage should keep percentage)\r\n            style.marginTop = this.marginTop + \"px\";\r\n            style.marginRight = this.marginRight + \"px\";\r\n            style.marginBottom = this.marginBottom + \"px\";\r\n            style.marginLeft = this.marginLeft + \"px\";\r\n\r\n            style.paddingTop = this.paddingTop + \"px\";\r\n            style.paddingRight = this.paddingRight + \"px\";\r\n            style.paddingBottom = this.paddingBottom + \"px\";\r\n            style.paddingLeft = this.paddingLeft + \"px\";\r\n\r\n            style.borderTop = this.borderTop + \"px\";\r\n            style.borderRight = this.borderRight + \"px\";\r\n            style.borderBottom = this.borderBottom + \"px\";\r\n            style.borderLeft = this.borderLeft + \"px\";\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n        * Calculates the bounds of the box-model relative to the toBox-model.\r\n        * @param boxModel The size/bounds-boxModel.\r\n        * @param toBox Where the bounds should be relative to.\r\n        * @return The bounds of the box-model relative to the toBox.\r\n        */\r\n        public bounds(boxModel?: IBoxModel, toBox?: IBoxModel, ret: geom.Rect2D = new geom.Rect2D()): geom.Rect2D {\r\n            boxModel = boxModel || BoxModel.BORDER;\r\n            toBox = toBox || BoxModel.BORDER;\r\n\r\n            var pt = new geom.Point3D(0, 0);\r\n            this.transform(pt, boxModel, toBox);\r\n\r\n            ret.x = pt.x;\r\n            ret.y = pt.y;\r\n            ret.width = boxModel.width(this);\r\n            ret.height = boxModel.height(this);\r\n\r\n            return ret;\r\n        }\r\n        \r\n        /**\r\n        * Transforms a point from one box-model to another. It does not clone the point, it will change it.\r\n        * @param point The point to transform. The coordinate system should be the fromBox-model.\r\n        * @param fromBox Where the point coordinates coming from.\r\n        * @param toBox The target coordinate-system/box-model.\r\n        * @return The transformed point.\r\n        */\r\n        public transform(point: geom.Point3D, fromBox?: IBoxModel, toBox?: IBoxModel): geom.Point3D {\r\n            if (toBox == fromBox)\r\n                return point;\r\n            if (fromBox)\r\n                fromBox.toBorderBox(this, point);\r\n            if (toBox)\r\n                toBox.fromBorderBox(this, point);\r\n            return point;\r\n        }\r\n\r\n        public width(boxModel?: IBoxModel): number {\r\n            return (boxModel || BoxModel.BORDER).width(this);\r\n        }\r\n\r\n        public height(boxModel?: IBoxModel): number {\r\n            return (boxModel || BoxModel.BORDER).height(this);\r\n        }\r\n\r\n        public dispose(): void {\r\n            this.clear();\r\n        }\r\n\r\n        public static lookup(boxSizing: string): IBoxModel {\r\n            for (var model in BoxModel) {\r\n                if ((<IBoxModel>model).name == boxSizing)//v != this && \r\n                    return model;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Attachment.ts",
      "size": 3241,
      "sizeMinified": 1382,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Attachment extends Background {\r\n        public name: string = \"attachment-box\";\r\n        protected getBackgroundBox(size: Box, ret: geom.Rect2D = new geom.Rect2D()): geom.Rect2D {\r\n            super.getBackgroundBox(size, ret);\r\n            //TODO: implement attachment handling corpointly\r\n            var attachment = size.style.backgroundAttachment;\r\n            if (attachment == \"scroll\")\r\n            { }\r\n            else if (attachment == \"local\") {\r\n                ret.x -= size.scrollLeft;\r\n                ret.y -= size.scrollTop;\r\n            }\r\n            else if (attachment == \"fixed\") {\r\n                if (system.Engine.isWebKit) {\r\n                    ret.x += size.element.ownerDocument.body.scrollLeft;\r\n                    ret.y += size.element.ownerDocument.body.scrollTop;\r\n                }\r\n                else {\r\n                    ret.x += size.element.ownerDocument.documentElement.scrollLeft;\r\n                    ret.y += size.element.ownerDocument.documentElement.scrollTop;\r\n                }\r\n                //transform to html\r\n                var trans = Transform.create(size.element);\r\n                var gl = trans.localToGlobal(0, 0, 0, BoxModel.PADDING, BoxModel.BORDER);\r\n                ret.x -= gl.x;\r\n                ret.y -= gl.y;\r\n            }\r\n            return ret;\r\n        }\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            var bb = this.getBackgroundBox(size);\r\n            var scaleX = bb.width / this._imageWidth;\r\n            var scaleY = bb.height / this._imageHeight;\r\n            point.x -= bb.x;\r\n            point.y -= bb.y;\r\n            point.x /= scaleX;\r\n            point.y /= scaleY;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            var bb = this.getBackgroundBox(size);\r\n            var scaleX = bb.width / this._imageWidth;\r\n            var scaleY = bb.height / this._imageHeight;\r\n            point.x *= scaleX;\r\n            point.y *= scaleY;\r\n            point.x += bb.x;\r\n            point.y += bb.y;\r\n        }\r\n    }\r\n    export var ATTACHMENT: IBoxModel = new Attachment();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Background.ts",
      "size": 5344,
      "sizeMinified": 2009,
      "code": "namespace jsidea.layout.BoxModel {\r\n    export class Background implements IBoxModel {\r\n        public name: string = \"background-box\";\r\n        private _image = new Image();\r\n        private _point = new geom.Point3D();\r\n        protected _imageWidth = 0;\r\n        protected _imageHeight = 0;\r\n        protected getBackgroundBox(size: Box, ret: geom.Rect2D = new geom.Rect2D()): geom.Rect2D {\r\n            var src = size.style.backgroundImage.replace(/url\\((['\"])?(.*?)\\1\\)/gi, '$2').split(',')[0];\r\n            var width: number;\r\n            var height: number;\r\n            if (!src || src == \"none\") {\r\n                width = size.offsetWidth;\r\n                height = size.offsetHeight;\r\n            }\r\n            else {\r\n                this._image.src = src;\r\n                width = this._image.width;\r\n                height = this._image.height;\r\n                if (isNaN(width))\r\n                    width = size.offsetWidth;\r\n                if (isNaN(height))\r\n                    height = size.offsetHeight;\r\n            }\r\n            //TODO: throw error or something similar\r\n            if (!width || !height)\r\n                return ret.setTo(0, 0, size.offsetWidth, size.offsetHeight);\r\n\r\n            this._imageWidth = width;\r\n            this._imageHeight = height;\r\n\r\n            var backgroundOrigin = size.style.backgroundOrigin ? Box.lookup(size.style.backgroundOrigin) : BoxModel.PADDING;\r\n            var origin = size.bounds(backgroundOrigin);\r\n\r\n            var x = 0;\r\n            var y = 0;\r\n\r\n            var cssPos = size.style.backgroundPosition.split(\" \");\r\n            var xPos: string = cssPos[0] || \"auto\";\r\n            var yPos: string = cssPos[1] || \"auto\";\r\n            var cssSize = size.style.backgroundSize.split(\" \");\r\n            var xSize: string = cssSize[0] || \"auto\";\r\n            var ySize: string = cssSize[1] || xSize;\r\n            var scaleX = origin.width / width;\r\n            var scaleY = origin.height / height;\r\n\r\n            if (xSize == \"auto\")\r\n            { }\r\n            else if (xSize == \"cover\")\r\n                width *= Math.max(scaleX, scaleY);\r\n            else if (xSize == \"contain\")\r\n                width *= Math.min(scaleX, scaleY);\r\n            else\r\n                width = math.Number.relation(xSize, origin.width, origin.width);\r\n\r\n            if (ySize == \"auto\") {\r\n                //keep ratio\r\n                if (xSize != \"auto\")\r\n                    height *= width / this._imageWidth;\r\n            }\r\n            else if (ySize == \"cover\")\r\n                height *= Math.max(scaleX, scaleY);\r\n            else if (ySize == \"contain\")\r\n                height *= Math.min(scaleX, scaleY);\r\n            else\r\n                height = math.Number.relation(ySize, origin.height, origin.height);\r\n\r\n            //keep ratio\r\n            if (xSize == \"auto\" && ySize != \"auto\")\r\n                width *= height / this._imageHeight;\r\n\r\n            if (xPos == \"auto\")\r\n            { }\r\n            else if (xPos.indexOf(\"%\") > 0)\r\n                x = math.Number.relation(xPos, origin.width, 0) - math.Number.relation(xPos, width, 0);\r\n            else\r\n                x = math.Number.relation(xPos, origin.width, 0);\r\n\r\n            if (yPos == \"auto\")\r\n            { }\r\n            else if (yPos.indexOf(\"%\") > 0)\r\n                y = math.Number.relation(yPos, origin.height, 0) - math.Number.relation(yPos, height, 0);\r\n            else\r\n                y = math.Number.relation(yPos, origin.height, 0);\r\n\r\n            //back to border box\r\n            var pt = size.transform(this._point.setTo(x, y, 0), backgroundOrigin, BoxModel.BORDER);\r\n\r\n            return ret.setTo(pt.x, pt.y, width, height);\r\n        }\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            var bb = this.getBackgroundBox(size);\r\n            point.x -= bb.x;\r\n            point.y -= bb.y;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            var bb = this.getBackgroundBox(size);\r\n            point.x += bb.x;\r\n            point.y += bb.y;\r\n        }\r\n        public width(size: Box): number {\r\n            return this.getBackgroundBox(size).width;\r\n        }\r\n        public height(size: Box): number {\r\n            return this.getBackgroundBox(size).height;\r\n        }\r\n    }\r\n    export var BACKGROUND: IBoxModel = new Background();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Border.ts",
      "size": 969,
      "sizeMinified": 412,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Border implements IBoxModel {\r\n        public name: string = \"border-box\";\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n        }\r\n        public width(size: Box): number {\r\n            return size.offsetWidth;\r\n        }\r\n        public height(size: Box): number {\r\n            return size.offsetHeight;\r\n        }\r\n    }\r\n    export var BORDER: IBoxModel = new Border();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Canvas.ts",
      "size": 3258,
      "sizeMinified": 1365,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Canvas implements IBoxModel {\r\n        public name: string = \"canvas-box\";\r\n        private _matrix = new geom.Matrix2D();\r\n        private check(size: Box): boolean {\r\n            return size.element && size.element instanceof HTMLCanvasElement;\r\n        }\r\n        private transform(invert: boolean, point: geom.Point3D, context: CanvasRenderingContext2D): void {\r\n            if (!context)\r\n                return;\r\n            this._matrix.setData(context.getTransform());\r\n            if (!this._matrix.isIdentity()) {\r\n                if (invert)\r\n                    this._matrix.invert();\r\n                var pt = this._matrix.transform(point);\r\n                point.x = pt.x;\r\n                point.y = pt.y;\r\n            }\r\n        }\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            if (this.check(size)) {\r\n                var element = <HTMLCanvasElement>size.element;\r\n                point.x *= element.width / (element.clientWidth - (size.paddingLeft + size.paddingRight));\r\n                point.y *= element.height / (element.clientHeight - (size.paddingTop + size.paddingBottom));\r\n                point.x += size.paddingLeft + size.borderLeft;\r\n                point.y += size.paddingTop + size.borderTop;\r\n\r\n                if (element.hasContext() == \"2d\") {\r\n                    var ctx = element.getContext(\"2d\");\r\n                    this.transform(true, point, ctx);\r\n                }\r\n            }\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            if (this.check(size)) {\r\n                var element = <HTMLCanvasElement>size.element;\r\n                point.x -= size.paddingLeft + size.borderLeft;\r\n                point.y -= size.paddingTop + size.borderTop;\r\n                point.x /= element.width / (element.clientWidth - (size.paddingLeft + size.paddingRight));\r\n                point.y /= element.height / (element.clientHeight - (size.paddingTop + size.paddingBottom));\r\n\r\n                if (element.hasContext() == \"2d\") {\r\n                    var ctx = element.getContext(\"2d\");\r\n                    this.transform(false, point, ctx);\r\n                }\r\n            }\r\n        }\r\n        public width(size: Box): number {\r\n            return this.check(size) ? (<HTMLCanvasElement>size.element).width : size.offsetWidth;\r\n        }\r\n        public height(size: Box): number {\r\n            return this.check(size) ? (<HTMLCanvasElement>size.element).height : size.offsetWidth;\r\n        }\r\n    }\r\n    export var CANVAS: IBoxModel = new Canvas();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Clip.ts",
      "size": 1549,
      "sizeMinified": 691,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Clip implements IBoxModel {\r\n        public name: string = \"clip-box\";\r\n        private _clip: geom.Rect2D = new geom.Rect2D();\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            var clip = geom.Rect2D.getClip(size.element, size.style, this._clip);\r\n            point.x -= clip.x;\r\n            point.y -= clip.y;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            var clip = geom.Rect2D.getClip(size.element, size.style, this._clip);\r\n            point.x += clip.x;\r\n            point.y += clip.y;\r\n        }\r\n        public width(size: Box): number {\r\n            var clip = geom.Rect2D.getClip(size.element, size.style, this._clip);\r\n            return clip.width;\r\n        }\r\n        public height(size: Box): number {\r\n            var clip = geom.Rect2D.getClip(size.element, size.style, this._clip);\r\n            return clip.height;\r\n        }\r\n    }\r\n    export var CLIP: IBoxModel = new Clip();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Content.ts",
      "size": 1403,
      "sizeMinified": 652,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Content implements IBoxModel {\r\n        public name: string = \"content-box\";\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x -= size.borderLeft + size.paddingLeft;\r\n            point.y -= size.borderTop + size.paddingTop;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x += size.borderLeft + size.paddingLeft;\r\n            point.y += size.borderTop + size.paddingTop;\r\n        }\r\n        public width(size: Box): number {\r\n            return size.offsetWidth - (size.borderLeft + size.borderRight + size.paddingLeft + size.paddingRight);\r\n        }\r\n        public height(size: Box): number {\r\n            return size.offsetHeight - (size.borderTop + size.borderBottom + size.paddingTop + size.paddingBottom);\r\n        }\r\n    }\r\n    export var CONTENT: IBoxModel = new Content();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Image.ts",
      "size": 2198,
      "sizeMinified": 993,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Image implements IBoxModel {\r\n        public name: string = \"image-box\";\r\n        private check(size: Box): boolean {\r\n            return size.element && size.element instanceof HTMLImageElement;\r\n        }\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            if (this.check(size)) {\r\n                var element = <HTMLImageElement>size.element;\r\n                point.x *= element.width / (element.clientWidth - (size.paddingLeft + size.paddingRight));\r\n                point.y *= element.height / (element.clientHeight - (size.paddingTop + size.paddingBottom));\r\n                point.x += size.paddingLeft + size.borderLeft;\r\n                point.y += size.paddingTop + size.borderTop;\r\n            }\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            if (this.check(size)) {\r\n                var element = <HTMLImageElement>size.element;\r\n                point.x -= size.paddingLeft + size.borderLeft;\r\n                point.y -= size.paddingTop + size.borderTop;\r\n                point.x /= element.width / (element.clientWidth - (size.paddingLeft + size.paddingRight));\r\n                point.y /= element.height / (element.clientHeight - (size.paddingTop + size.paddingBottom));\r\n            }\r\n        }\r\n        public width(size: Box): number {\r\n            return this.check(size) ? (<HTMLImageElement>size.element).width : size.offsetWidth;\r\n        }\r\n        public height(size: Box): number {\r\n            return this.check(size) ? (<HTMLImageElement>size.element).height : size.offsetWidth;\r\n        }\r\n    }\r\n    export var IMAGE: IBoxModel = new Image();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Margin.ts",
      "size": 1237,
      "sizeMinified": 534,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Margin implements IBoxModel {\r\n        public name: string = \"margin-box\";\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x += size.marginLeft;\r\n            point.y += size.marginTop;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x -= size.marginLeft;\r\n            point.y -= size.marginTop;\r\n        }\r\n        public width(size: Box): number {\r\n            return size.offsetWidth + size.marginLeft + size.marginRight;\r\n        }\r\n        public height(size: Box): number {\r\n            return size.offsetHeight + size.marginTop + size.marginBottom;\r\n        }\r\n    }\r\n    export var MARGIN: IBoxModel = new Margin();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/NormalDeviceCoordinates.ts",
      "size": 1643,
      "sizeMinified": 660,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class NormalDeviceCoordinates implements IBoxModel {\r\n        public name: string = \"normal-device-coordinates-box\";\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x /= size.offsetWidth * 0.5;\r\n            point.y /= size.offsetHeight * 0.5;\r\n            point.x -= 1;\r\n            point.y -= 1;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x += 1;\r\n            point.y += 1;\r\n            point.x *= size.offsetWidth * 0.5;\r\n            point.y *= size.offsetHeight * 0.5;\r\n        }\r\n        public width(size: Box): number {\r\n            return size.offsetWidth - (size.borderLeft + size.borderRight + size.paddingLeft + size.paddingRight);\r\n        }\r\n        public height(size: Box): number {\r\n            return size.offsetHeight - (size.borderTop + size.borderBottom + size.paddingTop + size.paddingBottom);\r\n        }\r\n    }\r\n    export var NDC: IBoxModel = new NormalDeviceCoordinates();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Padding.ts",
      "size": 1251,
      "sizeMinified": 540,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Padding implements IBoxModel {\r\n        public name: string = \"padding-box\";\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x -= size.borderLeft;\r\n            point.y -= size.borderTop;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            point.x += size.borderLeft;\r\n            point.y += size.borderTop;\r\n        }\r\n        public width(size: Box): number {\r\n            return size.offsetWidth - (size.borderLeft + size.borderRight);\r\n        }\r\n        public height(size: Box): number {\r\n            return size.offsetHeight - (size.borderTop + size.borderBottom);\r\n        }\r\n    }\r\n    export var PADDING: IBoxModel = new Padding();\r\n}"
    },
    {
      "name": "src/jsidea/layout/BoxModel/Scroll.ts",
      "size": 1661,
      "sizeMinified": 663,
      "code": "namespace jsidea.layout.BoxModel {\r\n    class Scroll implements IBoxModel {\r\n        public name: string = \"scroll-box\";\r\n        private getScroll(size: Box): geom.Point2D {\r\n            var scrollLeft = size.scrollLeft;\r\n            var scrollTop = size.scrollTop;\r\n            return new geom.Point2D(scrollLeft, scrollTop);\r\n        }\r\n        public fromBorderBox(size: Box, point: geom.Point3D): void {\r\n            var scroll = this.getScroll(size);\r\n            BoxModel.PADDING.toBorderBox(size, point);\r\n            point.x += scroll.x;\r\n            point.y += scroll.y;\r\n        }\r\n        public toBorderBox(size: Box, point: geom.Point3D): void {\r\n            var scroll = this.getScroll(size);\r\n            BoxModel.PADDING.toBorderBox(size, point);\r\n            point.x -= scroll.x;\r\n            point.y -= scroll.y;\r\n        }\r\n        public width(size: Box): number {\r\n            return size.element.scrollWidth;\r\n        }\r\n        public height(size: Box): number {\r\n            return size.element.scrollHeight;\r\n        }\r\n    }\r\n    export var SCROLL: IBoxModel = new Scroll();\r\n}"
    },
    {
      "name": "src/jsidea/layout/IBoxModel.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IBoxModel {\r\n        name: string;\r\n        fromBorderBox(size: Box, point: geom.Point3D): void;\r\n        toBorderBox(size: Box, point: geom.Point3D): void;\r\n        width(size: Box): number;\r\n        height(size: Box): number;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/IMoveLimits.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IMoveLimits {\r\n        minX?: any;\r\n        maxX?: any;\r\n        minY?: any;\r\n        maxY?: any;\r\n        minZ?: any;\r\n        maxZ?: any;\r\n        boxModel?: IBoxModel;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/IMoveMode.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IMoveMode {\r\n        willChange?: string;\r\n        boxModel?: IBoxModel;\r\n        invertX?: boolean;\r\n        invertY?: boolean;\r\n        transform(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D;\r\n        clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void;\r\n        apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/IPositionFrom.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IPositionFrom extends IPositionTo, math.ILimit {\r\n        element?: HTMLElement;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/IPositionTo.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IPositionTo {\r\n        x?: any;\r\n        y?: any;\r\n        offsetX?: any;\r\n        offsetY?: any;\r\n        boxModel?: IBoxModel;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/ISnapGrid.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface ISnapGrid {\r\n        element?: HTMLElement;\r\n        boxModel?: IBoxModel;\r\n        x?: any;\r\n        y?: any;\r\n        offsetX?: any;\r\n        offsetY?: any;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/ISnapMode.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface ISnapMode {\r\n        transform(snap: Snap, transform: Transform, point: geom.Point3D): void;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/ISnapTo.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface ISnapTo {\r\n        element?: HTMLElement;\r\n        x?: any;\r\n        y?: any;\r\n        offsetX?: any;\r\n        offsetY?: any;\r\n        boxModel?: IBoxModel;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/IStyleNode.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface IStyleNode {\r\n        //re-cast\r\n        element: HTMLElement;\r\n        style: CSSStyleDeclaration;\r\n        depth: number;\r\n        isBody: boolean;\r\n        isHTML: boolean;\r\n        isTransformed: boolean;\r\n        isTransformed3D: boolean;\r\n        isPreserved3d: boolean;\r\n        isScrollable: boolean;\r\n        perspective: number;\r\n        isForced2D: boolean;\r\n        first: IStyleNode;\r\n        last: IStyleNode;\r\n        child: IStyleNode;\r\n        parent: IStyleNode;\r\n        offsetParent: IStyleNode;\r\n        offsetParentRaw: IStyleNode;\r\n        parentScroll: IStyleNode;\r\n        offset: geom.Point2D;\r\n        offsetUnscrolled: geom.Point2D;\r\n        position: geom.Point2D;\r\n        scrollOffset: geom.Point2D;\r\n        offsetLeft: number;\r\n        offsetTop: number;\r\n        clientLeft: number;\r\n        clientTop: number;\r\n        isRelative: boolean;\r\n        isAbsolute: boolean;\r\n        isStatic: boolean;\r\n        isFixed: boolean;\r\n        isFixedChild: boolean;\r\n        isFixedZombie: boolean;\r\n        isSticked: boolean;\r\n        isStickedChild: boolean;\r\n        isTransformedChild: boolean;\r\n        isPerspectiveChild: boolean;\r\n        isPreserved3dOrPerspective: boolean;\r\n        isPreserved3dChild: boolean;\r\n        isBorderBox: boolean;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/ITransformMode.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.layout {\r\n    export interface ITransformMode {\r\n        extract(transform: Transform, matrix: geom.Matrix3D): void;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/Move.ts",
      "size": 1926,
      "sizeMinified": 792,
      "code": "namespace jsidea.layout {\r\n    export class Move {\r\n        public position: geom.Point3D = new geom.Point3D();\r\n        public limits: IMoveLimits = {};\r\n        public mode: IMoveMode = null;\r\n        \r\n        public static DEFAULT: Move = new Move();\r\n\r\n        constructor() {\r\n        }\r\n\r\n        public static create(): Move {\r\n            return new Move();\r\n        }\r\n\r\n        public clone(): Move {\r\n            return (new Move()).copyFrom(this);\r\n        }\r\n\r\n        public copyFrom(move: Move): Move {\r\n            this.position.copyFrom(move.position);\r\n            this.limits = move.limits;\r\n            this.mode = move.mode;\r\n            return this;\r\n        }\r\n\r\n        public static apply(options: Move, transform: Transform): void {\r\n            if (!transform)\r\n                return;\r\n            options = options || Move.DEFAULT;\r\n            \r\n            var mode = options.mode || MoveMode.TRANSFORM;\r\n            var point = options.position.clone();\r\n            var style = transform.size.style;\r\n            var size = transform.size;\r\n            var element = transform.element;\r\n            \r\n            //the point in \"Position\"-space\r\n            mode.transform(point, element, style);\r\n            \r\n            //clamp by \"limits\" property\r\n            var toBox = options.limits.boxModel || BoxModel.BORDER;\r\n            var bounds = size.bounds(toBox);\r\n            math.Number.limits(point, options.limits, bounds.width, bounds.height);\r\n            \r\n            //clamp it by its \"natural\" limits\r\n            mode.clamp(point, element, style);\r\n            \r\n            //apply the final point\r\n            mode.apply(point, element, style);\r\n        }\r\n\r\n        public dispose(): void {\r\n            this.limits = null;\r\n            this.mode = null;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/Background.ts",
      "size": 1503,
      "sizeMinified": 667,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class Background implements IMoveMode {\r\n        public boxModel: IBoxModel = BoxModel.BACKGROUND;\r\n        public willChange: string = \"contents\";\r\n        public invertX: boolean = false;\r\n        public invertY: boolean = false;\r\n        private _rect: geom.Rect2D = new geom.Rect2D();\r\n        private _size: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var rect = this._rect;\r\n            this._size.update(element, style);\r\n            this._size.bounds(BoxModel.BACKGROUND, BoxModel.PADDING, rect);\r\n            return offset.translate(\r\n                rect.x,\r\n                rect.y,\r\n                0);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            element.style.backgroundPosition = Math.round(point.x) + \"px \" + Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n\r\n    export var BACKGROUND: IMoveMode = new Background();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/BorderBottomRightInner.ts",
      "size": 3460,
      "sizeMinified": 1380,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class BorderBottomRightInner implements IMoveMode {\r\n        public boxModel: IBoxModel = BoxModel.BORDER;\r\n        public willChange: string = \"contents\";\r\n        private _size: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var bs = this._size;\r\n            bs.update(element, style);\r\n\r\n            //if horizontal border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.right != \"auto\" && style.right != \"auto\")) {\r\n                offset.x *= -1;\r\n                offset.x += bs.borderRight;\r\n            }\r\n            else {\r\n                offset.x = bs.borderRight;\r\n            }\r\n\r\n            //if vertical border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.top != \"auto\" && style.bottom != \"auto\")) {\r\n                offset.y *= -1;\r\n                offset.y += bs.borderBottom;\r\n            }\r\n            else {\r\n                offset.y = bs.borderBottom;\r\n            }\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            this._size.update(element, style);\r\n            var right = isNaN(point.x) ? this._size.borderRight : Math.round(point.x);\r\n            var bottom = isNaN(point.y) ? this._size.borderBottom : Math.round(point.y);\r\n            element.style.borderWidth = this._size.borderTop + \"px \" + right + \"px \" + bottom + \"px \" + this._size.borderLeft + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            var bs = this._size;\r\n            bs.update(element, style);\r\n            //if horizontal border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.left != \"auto\" && style.right != \"auto\")) {\r\n                point.x = Math.max(point.x, 0);\r\n                var minWidth = math.Number.parse(style.minWidth, 0);\r\n                var maxX = bs.offsetWidth - (bs.borderLeft + bs.paddingLeft + bs.paddingRight) - minWidth;\r\n                point.x = Math.min(maxX, point.x);\r\n            }\r\n            else {\r\n                point.x = bs.borderRight;\r\n            }\r\n\r\n            //if vertical border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.top != \"auto\" && style.bottom != \"auto\")) {\r\n                //clamp\r\n                point.y = Math.max(point.y, 0);\r\n                var minHeight = math.Number.parse(style.minHeight, 0);\r\n                var maxY = bs.offsetHeight - (bs.borderTop + bs.paddingTop + bs.paddingBottom) - minHeight;\r\n                point.y = Math.min(maxY, point.y);\r\n            }\r\n            else {\r\n                point.y = bs.borderBottom;\r\n            }\r\n        }\r\n    }\r\n\r\n    export var BORDER_BOTTOM_RIGHT_INNER: IMoveMode = new BorderBottomRightInner();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/BorderBottomRightOuter.ts",
      "size": 2120,
      "sizeMinified": 878,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class BorderBottomRightOuter implements IMoveMode {\r\n        public willChange: string = \"contents\";\r\n        private _size: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var bs = this._size;\r\n            bs.update(element, style);\r\n\r\n            //if horizontal border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.left != \"auto\" && style.right != \"auto\"))\r\n                offset.x = bs.borderRight;\r\n            else\r\n                offset.x += bs.borderRight;\r\n\r\n            //if vertical border increases inside\r\n            if (style.boxSizing == \"border-box\" || (style.top != \"auto\" && style.bottom != \"auto\"))\r\n                offset.y = bs.borderBottom;\r\n            else\r\n                offset.y += bs.borderBottom;\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            this._size.update(element, style);\r\n            var right = isNaN(point.x) ? this._size.borderRight : Math.round(point.x);\r\n            var bottom = isNaN(point.y) ? this._size.borderBottom : Math.round(point.y);\r\n            element.style.borderWidth = this._size.borderTop + \"px \" + right + \"px \" + bottom + \"px \" + this._size.borderLeft + \"px\";\r\n        }\r\n\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            point.x = Math.max(point.x, 0);\r\n            point.y = Math.max(point.y, 0);\r\n        }\r\n    }\r\n\r\n    export var BORDER_BOTTOM_RIGHT_OUTER: IMoveMode = new BorderBottomRightOuter();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/BorderTopLeft.ts",
      "size": 1626,
      "sizeMinified": 767,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class BorderTopLeft implements IMoveMode {\r\n        public willChange: string = \"contents\";\r\n        private _boxSizing: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            this._boxSizing.update(element, style);\r\n            return offset.translate(\r\n                this._boxSizing.borderLeft,\r\n                this._boxSizing.borderTop,\r\n                0);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            this._boxSizing.update(element, style);\r\n            var left = isNaN(point.x) ? this._boxSizing.borderLeft : Math.round(point.x);\r\n            var top = isNaN(point.y) ? this._boxSizing.borderTop : Math.round(point.y);\r\n            element.style.borderWidth = top + \"px \" + this._boxSizing.borderRight + \"px \" + this._boxSizing.borderBottom + \"px \" + left + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            //clamp min\r\n            point.x = Math.max(point.x, 0);\r\n            point.y = Math.max(point.y, 0);\r\n        }\r\n    }\r\n\r\n    export var BORDER_TOP_LEFT: IMoveMode = new BorderTopLeft();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/BottomLeft.ts",
      "size": 1653,
      "sizeMinified": 700,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class BottomLeft implements IMoveMode {\r\n        public willChange: string = \"bottom, left\";\r\n        public invertX: boolean = false;\r\n        public invertY: boolean = true;\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var bottom = MoveMode.BOTTOM_RIGHT.transform(offset.clone(), element, style);\r\n            var left = MoveMode.TOP_LEFT.transform(offset.clone(), element, style);\r\n            return offset.setTo(left.x, bottom.y, offset.z);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position === \"static\") {\r\n                console.warn(\"You cannot apply BottomLeftMode to an static element.\");\r\n                return;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.style.left = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.bottom = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n    export var BOTTOM_LEFT: IMoveMode = new BottomLeft();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/BottomRight.ts",
      "size": 4733,
      "sizeMinified": 1539,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class BottomRight implements IMoveMode {\r\n        public willChange: string = \"bottom, right\";\r\n        public invertX: boolean = true;\r\n        public invertY: boolean = true;\r\n        private _size: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var offsetX = offset.x;\r\n            var offsetY = offset.y;\r\n            var rightAuto = style.right == \"auto\";\r\n            var bottomAuto = style.bottom == \"auto\";\r\n            if (rightAuto || bottomAuto) {\r\n                MoveMode.TOP_LEFT.transform(offset, element, style);\r\n\r\n                var parentWidth = 0;\r\n                var parentHeight = 0;\r\n                if (element.parentElement) {\r\n                    parentWidth = element.parentElement.clientWidth;\r\n                    parentHeight = element.parentElement.clientHeight;\r\n                }\r\n\r\n                if (style.position == \"fixed\") {\r\n                    var node = layout.StyleNode.create(element);\r\n                    if (node.isSticked) {\r\n                        var body = element.ownerDocument.body;\r\n                        parentWidth = body.clientWidth;\r\n                        parentHeight = body.clientHeight;\r\n                    }\r\n                    this._size.update(element);\r\n                    offset.x += this._size.marginLeft;\r\n                    offset.y += this._size.marginTop;\r\n                    offset.x += this._size.marginRight;\r\n                    offset.y += this._size.marginBottom;\r\n\r\n                    offset.x += element.offsetWidth;\r\n                    offset.y += element.offsetHeight;\r\n                    offset.x = parentWidth - offset.x;\r\n                    offset.y = parentHeight - offset.y;\r\n                }\r\n                //if its relative the bottom/right are offset to \"calced\"/layout-position\r\n                else if (style.position == \"relative\") {\r\n                    offset.x = -offset.x;\r\n                    offset.y = -offset.y;\r\n                    return offset;\r\n                }\r\n                else {\r\n                    offset.x += element.offsetWidth;\r\n                    offset.y += element.offsetHeight;\r\n                    offset.x = parentWidth - offset.x;\r\n                    offset.y = parentHeight - offset.y;\r\n                }\r\n            }\r\n            else {\r\n                offset.setTo(\r\n                    math.Number.parse(style.right, 0) - offset.x,\r\n                    math.Number.parse(style.bottom, 0) - offset.y,\r\n                    offset.z);\r\n            }\r\n\r\n            var leftAuto = style.left == \"auto\";\r\n            var minWidth = math.Number.parse(style.minWidth, 0);\r\n            if (!leftAuto) {\r\n                var newWidth = element.clientWidth + offsetX;\r\n                if (newWidth < minWidth)\r\n                    offset.x += newWidth - minWidth;\r\n            }\r\n\r\n            var topAuto = style.top == \"auto\";\r\n            var minHeight = math.Number.parse(style.minHeight, 0);\r\n            if (!topAuto) {\r\n                var newHeight = element.clientHeight + offsetY;\r\n                if (newHeight < minHeight)\r\n                    offset.y += newHeight - minHeight;\r\n            }\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position === \"static\") {\r\n                console.warn(\"You cannot apply BottomRightMode to an static element.\");\r\n                return;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.style.right = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.bottom = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            //            var leftAuto = style.left == \"auto\";\r\n            //            var minWidth = math.Number.parse(style.minWidth, 0);\r\n            //            if (!leftAuto) {\r\n            //                var newWidth = element.clientWidth + offsetX;\r\n            //                if (newWidth < minWidth)\r\n            //                    point.x += newWidth - minWidth;\r\n            //            }\r\n            //\r\n            //            var topAuto = style.top == \"auto\";\r\n            //            var minHeight = math.Number.parse(style.minHeight, 0);\r\n            //            if (!topAuto) {\r\n            //                var newHeight = element.clientHeight + offsetY;\r\n            //                if (newHeight < minHeight)\r\n            //                    point.y += newHeight - minHeight;\r\n            //            }\r\n        }\r\n    }\r\n    \r\n    export var BOTTOM_RIGHT: IMoveMode = new BottomRight();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/Clip.ts",
      "size": 1605,
      "sizeMinified": 717,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class Clip implements IMoveMode {\r\n        public boxModel: IBoxModel = BoxModel.CLIP;\r\n        public willChange: string = \"contents\";\r\n        private _clip: geom.Rect2D = new geom.Rect2D();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var clip = geom.Rect2D.getClip(element, style, this._clip);\r\n            return offset.translate(\r\n                clip.x,\r\n                clip.y,\r\n                0);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position != \"absolute\" && style.position != \"fixed\")\r\n                return console.warn(\"You cannot apply clipping to an \" + style.position + \"-positioned element\");\r\n\r\n            var clip = geom.Rect2D.getClip(element, style, this._clip);\r\n            if (!isNaN(point.x))\r\n                clip.x = point.x;\r\n            if (!isNaN(point.y))\r\n                clip.y = point.y;\r\n            element.style.clip = clip.getCSS();\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n\r\n    export var CLIP: IMoveMode = new Clip();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/ClipBottomRight.ts",
      "size": 1796,
      "sizeMinified": 771,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class ClipBottomRight implements IMoveMode {\r\n        public boxModel: IBoxModel = BoxModel.CLIP;\r\n        public willChange: string = \"contents\";\r\n        private _clip: geom.Rect2D = new geom.Rect2D();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var clip = geom.Rect2D.getClip(element, style, this._clip);\r\n            offset.translate(\r\n                clip.right,\r\n                clip.bottom,\r\n                0);\r\n            console.log(offset.x, offset.y);\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position != \"absolute\" && style.position != \"fixed\")\r\n                return console.warn(\"You cannot apply clipping to an \" + style.position + \"-positioned element\");\r\n\r\n            var clip = geom.Rect2D.getClip(element, style, this._clip);\r\n            if (!isNaN(point.x))\r\n                clip.right = point.x;\r\n            if (!isNaN(point.y))\r\n                clip.bottom = point.y;\r\n            element.style.clip = clip.getCSS();\r\n        }\r\n\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n\r\n    export var CLIP_BOTTOM_RIGHT: IMoveMode = new ClipBottomRight();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/MarginBottomRight.ts",
      "size": 1732,
      "sizeMinified": 664,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class MarginBottomRight implements IMoveMode {\r\n        public willChange: string = \"auto\";\r\n        public invertX: boolean = true;\r\n        public invertY: boolean = true;\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var rightAuto = style.marginRight == \"auto\";\r\n            var bottomAuto = style.marginBottom == \"auto\";\r\n\r\n            offset.x *= -1;\r\n            offset.y *= -1;\r\n\r\n            if (rightAuto || bottomAuto) {\r\n                //TODO: implement retrieval of the margin values\r\n            }\r\n            else\r\n                offset.translate(\r\n                    math.Number.parse(style.marginRight, 0),\r\n                    math.Number.parse(style.marginBottom, 0),\r\n                    0);\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (!isNaN(point.x))\r\n                element.style.marginRight = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.marginBottom = Math.round(point.y) + \"px\";\r\n        }\r\n\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n\r\n    export var MARGIN_BOTTOM_RIGHT: IMoveMode = new MarginBottomRight();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/MarginTopLeft.ts",
      "size": 1522,
      "sizeMinified": 600,
      "code": "namespace jsidea.layout.MoveMode {\r\n     class MarginTopLeft implements IMoveMode {\r\n        public willChange: string = \"auto\";\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var leftAuto = style.marginLeft == \"auto\";\r\n            var topAuto = style.marginTop == \"auto\";\r\n            if (leftAuto || topAuto) {\r\n                //TODO: implement retrieval of the margin values\r\n            }\r\n            else\r\n                offset.translate(\r\n                    math.Number.parse(style.marginLeft, 0),\r\n                    math.Number.parse(style.marginTop, 0),\r\n                    0);\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (!isNaN(point.x))\r\n                element.style.marginLeft = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.marginTop = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n    export var MARGIN_TOP_LEFT: IMoveMode = new MarginTopLeft();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/Scroll.ts",
      "size": 1977,
      "sizeMinified": 783,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class Scroll implements IMoveMode {\r\n        public boxModel: IBoxModel = BoxModel.SCROLL;\r\n        public willChange: string = \"scroll-position\";\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var scrollLeft = element.scrollLeft;\r\n            var scrollTop = element.scrollTop;\r\n\r\n            if (!system.Engine.isWebKit && element.ownerDocument.body == element) {\r\n                scrollLeft = element.ownerDocument.documentElement.scrollLeft;\r\n                scrollTop = element.ownerDocument.documentElement.scrollTop;\r\n            }\r\n\r\n            offset.x *= -1;\r\n            offset.y *= -1;\r\n            offset.translate(\r\n                scrollLeft,\r\n                scrollTop,\r\n                0);\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (!system.Engine.isWebKit && element == element.ownerDocument.body) {\r\n                element = element.ownerDocument.documentElement;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.scrollLeft = point.x;\r\n            if (!isNaN(point.y))\r\n                element.scrollTop = point.y;\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            point.x = Math.max(point.x, 0);\r\n            point.y = Math.max(point.y, 0);\r\n            //TODO: clamp by scrollWidth ... \r\n        }\r\n    }\r\n\r\n    export var SCROLL: IMoveMode = new Scroll();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/TopLeft.ts",
      "size": 6302,
      "sizeMinified": 2582,
      "code": "namespace jsidea.layout.MoveMode {\r\n   class TopLeft implements IMoveMode {\r\n        public willChange: string = \"top, left\";\r\n        private _sizeParent: Box = Box.create();\r\n        private _size: Box = Box.create();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            //!IMPORTANT: style needs to be an computed style not the element's style-property\r\n            \r\n            var leftAuto = style.left == \"auto\";\r\n            var topAuto = style.top == \"auto\";\r\n            if (leftAuto || topAuto) {\r\n                if (system.Engine.isWebKit) {\r\n                    var node = StyleNode.create(element);\r\n                    var position = new geom.Point3D();\r\n                    if (node.isRelative) {\r\n                        this._size.update(node.element, node.style);\r\n                        this._sizeParent.update(node.parent.element, node.parent.style);\r\n                        position.x = node.position.x - node.parent.clientLeft;\r\n                        position.y = node.position.y - node.parent.clientTop;\r\n                        position.x -= this._sizeParent.paddingLeft;\r\n                        position.y -= this._sizeParent.paddingTop;\r\n                        position.x -= this._size.marginLeft;\r\n                        position.y -= this._size.marginTop;\r\n                    }\r\n                    else if (node.isSticked) {\r\n                        //get the offset to body\r\n                        position.x = node.offset.x;\r\n                        position.y = node.offset.y;\r\n                        //subtract body's margin and scroll values\r\n                        this._size.update(node.element, node.style);\r\n                        position.x -= element.ownerDocument.body.scrollLeft + this._size.marginLeft;\r\n                        position.y -= element.ownerDocument.body.scrollTop + this._size.marginTop;\r\n                    }\r\n                    else if (node.isAbsolute) {\r\n                        //get the offset to offsetParent\r\n                        var par = node.offsetParent ? node.offsetParent : node.first;\r\n                        position.x = node.offset.x - par.offset.x;\r\n                        position.y = node.offset.y - par.offset.y;\r\n                        //subtract the parent's border\r\n                        position.x -= node.parent.clientLeft;\r\n                        position.y -= node.parent.clientTop;\r\n                    }\r\n                    else {\r\n                        this._size.update(node.element, node.style);\r\n                        this._sizeParent.update(node.parent.element, node.parent.style);\r\n                        position.x = node.position.x + this._sizeParent.paddingLeft - this._size.marginLeft;\r\n                        position.y = node.position.y + this._sizeParent.paddingTop - this._size.marginTop;\r\n                        this._sizeParent.transform(position, BoxModel.BORDER, BoxModel.CONTENT);\r\n                    }\r\n                    return offset.translate(\r\n                        position.x,\r\n                        position.y,\r\n                        0);\r\n                }\r\n                //TODO: its not running fine...\r\n                else if (system.Browser.isInternetExplorer) {\r\n                    this._size.update(element, style);\r\n                    var dx = element.offsetLeft;\r\n                    var dy = element.offsetTop;\r\n                    if (style.position == \"relative\") {\r\n                        this._sizeParent.update(element.parentElement);\r\n                        if (element.parentElement == element.ownerDocument.body) {\r\n                            dx -= this._size.marginLeft + this._sizeParent.borderLeft;\r\n                            dy -= this._size.marginTop + this._sizeParent.borderRight;\r\n                        }\r\n                        else {\r\n                            dx -= this._size.marginLeft + this._sizeParent.paddingLeft;\r\n                            dy -= this._size.marginTop + this._sizeParent.paddingTop;\r\n                        }\r\n                    }\r\n                    else if (style.position == \"fixed\") {\r\n                        this._sizeParent.update(element.ownerDocument.body);\r\n                        dx -= this._size.marginLeft + this._sizeParent.paddingLeft;\r\n                        dy -= this._size.marginTop + this._sizeParent.paddingTop;\r\n                    }\r\n                    else if (style.position == \"absolute\") {\r\n                        dx -= this._size.marginLeft;\r\n                        dy -= this._size.marginTop;\r\n                    }\r\n                    return offset.translate(\r\n                        math.Number.parse(style.left, dx),\r\n                        math.Number.parse(style.top, dy),\r\n                        0);\r\n                }\r\n                else if (system.Browser.isFirefox) {\r\n                    //nice: firefox reflects the top left in any case\r\n                    //i think this is not w3c conform, but its the best solution\r\n                }\r\n            }\r\n\r\n            return offset.translate(\r\n                math.Number.parse(style.left, 0),\r\n                math.Number.parse(style.top, 0),\r\n                0);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position === \"static\") {\r\n                console.warn(\"You cannot apply TopLeftMode to an static element.\");\r\n                return;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.style.left = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.top = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n   export var TOP_LEFT: IMoveMode = new TopLeft();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/TopLeftClamped.ts",
      "size": 2320,
      "sizeMinified": 821,
      "code": "namespace jsidea.layout.MoveMode {\r\n   class TopLeftClamped implements IMoveMode {\r\n        public willChange: string = \"top, left\";\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var offsetX = offset.x;\r\n            var offsetY = offset.y;\r\n            MoveMode.TOP_LEFT.transform(offset, element, style);\r\n\r\n            var rightAuto = style.right == \"auto\";\r\n            var minWidth = math.Number.parse(style.minWidth, 0);\r\n            if (!rightAuto) {\r\n                var newWidth = element.clientWidth - offsetX;\r\n                if (newWidth < minWidth)\r\n                    offset.x += newWidth - minWidth;\r\n            }\r\n\r\n            var bottomAuto = style.bottom == \"auto\";\r\n            var minHeight = math.Number.parse(style.minHeight, 0);\r\n            if (!bottomAuto) {\r\n                var newHeight = element.clientHeight - offsetY;\r\n                if (newHeight < minHeight)\r\n                    offset.y += newHeight - minHeight;\r\n            }\r\n\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position === \"static\") {\r\n                console.warn(\"You cannot apply TopLeftModeClamped to an static element.\");\r\n                return;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.style.left = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.top = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n   export var TOP_LEFT_CLAMPED: IMoveMode = new TopLeftClamped();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/TopRight.ts",
      "size": 1627,
      "sizeMinified": 692,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class TopRight implements IMoveMode {\r\n        public willChange: string = \"top, right\";\r\n        public invertX: boolean = true;\r\n        public invertY: boolean = false;\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            var top = MoveMode.TOP_LEFT.transform(offset.clone(), element, style);\r\n            var right = MoveMode.BOTTOM_RIGHT.transform(offset.clone(), element, style);\r\n            return offset.setTo(right.x, top.y, offset.z);\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            if (style.position === \"static\") {\r\n                console.warn(\"You cannot apply TopRightMode to an static element.\");\r\n                return;\r\n            }\r\n            if (!isNaN(point.x))\r\n                element.style.right = Math.round(point.x) + \"px\";\r\n            if (!isNaN(point.y))\r\n                element.style.top = Math.round(point.y) + \"px\";\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n    export var TOP_RIGHT: IMoveMode = new TopRight();\r\n}"
    },
    {
      "name": "src/jsidea/layout/MoveMode/Transform.ts",
      "size": 1516,
      "sizeMinified": 607,
      "code": "namespace jsidea.layout.MoveMode {\r\n    class Transform implements IMoveMode {\r\n        public willChange: string = \"transform\";\r\n        protected _matrix: geom.Matrix3D = new geom.Matrix3D();\r\n        public transform(offset: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): geom.Point3D {\r\n            return offset;\r\n        }\r\n        public apply(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n            var matrix = geom.Matrix3D.create(element, style, this._matrix);\r\n\r\n            if (!isNaN(point.x))\r\n                matrix.m41 = point.x;\r\n            if (!isNaN(point.y))\r\n                matrix.m42 = point.y;\r\n            if (!isNaN(point.z))\r\n                matrix.m43 = point.z;\r\n\r\n            //WebKit bug\r\n            if (system.Engine.isWebKit)\r\n                matrix.m43 *= 1 / (window.innerWidth / window.outerWidth);\r\n            element.style.transform = matrix.getCSS();\r\n        }\r\n        public clamp(point: geom.Point3D, element: HTMLElement, style: CSSStyleDeclaration): void {\r\n        }\r\n    }\r\n    \r\n    export var TRANSFORM:IMoveMode = new Transform();\r\n}"
    },
    {
      "name": "src/jsidea/layout/Position.ts",
      "size": 4354,
      "sizeMinified": 1915,
      "code": "namespace jsidea.layout {\r\n    export class Position {\r\n        public to: IPositionTo = {};\r\n        public from: IPositionFrom = {};\r\n        public snap: Snap = null;\r\n        public move: Move = new Move();\r\n\r\n        private static _from: Transform = new Transform();\r\n        private static _bounds: Transform = new Transform();\r\n\r\n        constructor() {\r\n        }\r\n\r\n        public static create(): Position {\r\n            return new Position();\r\n        }\r\n\r\n        public clone(): Position {\r\n            return (new Position()).copyFrom(this);\r\n        }\r\n\r\n        public copyFrom(position: Position): Position {\r\n            this.to = position.to;\r\n            this.from = position.from;\r\n            this.move = position.move;\r\n            return this;\r\n        }\r\n\r\n        public static apply(position: Position, element: HTMLElement): void {\r\n            if (!element)\r\n                return null;\r\n            \r\n            var transform = Transform.create(element);\r\n            Position.calc(position, transform, position.move.position);\r\n            Move.apply(position.move, transform);\r\n\r\n            if (position.snap) {\r\n                //maybe optional\r\n                position.snap.move.mode = position.move.mode;\r\n                \r\n                Snap.apply(position.snap, element);\r\n            }\r\n        }\r\n\r\n        public static calcByElement(position: Position, element: HTMLElement): geom.Point3D {\r\n            return Position.calc(position, Transform.create(element));\r\n        }\r\n\r\n        public static calc(position: Position, transform: Transform, ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n            if (!transform)\r\n                return ret;\r\n\r\n            //retrieve \"of\"-element\r\n            var fromElement = position.from.element || transform.element.ownerDocument.documentElement;\r\n\r\n            Position._from.update(fromElement);\r\n\r\n            var toBox = position.to.boxModel || BoxModel.BORDER;\r\n            var fromBox = position.from.boxModel || BoxModel.BORDER;\r\n            \r\n            //transform box-models of \"to\"\r\n            var sizeTo = transform.size.bounds(toBox);\r\n            var toX: number = math.Number.relation(position.to.x, sizeTo.width, 0) + math.Number.relation(position.to.offsetX, sizeTo.width, 0);\r\n            var toY: number = math.Number.relation(position.to.y, sizeTo.height, 0) + math.Number.relation(position.to.offsetY, sizeTo.height, 0);\r\n            \r\n            //transform box-models of \"from\"\r\n            var sizeFrom = Position._from.size.bounds(fromBox);\r\n            var fromX: number = math.Number.relation(position.from.x, sizeFrom.width, 0) + math.Number.relation(position.from.offsetX, sizeFrom.width, 0);\r\n            var fromY: number = math.Number.relation(position.from.y, sizeFrom.height, 0) + math.Number.relation(position.from.offsetY, sizeFrom.height, 0);\r\n            \r\n            //clamp from\r\n            if (position.from.minX !== undefined)\r\n                fromX = Math.max(fromX, math.Number.relation(position.from.minX, sizeFrom.width, fromX));\r\n            if (position.from.maxX !== undefined)\r\n                fromX = Math.min(fromX, math.Number.relation(position.from.maxX, sizeFrom.width, fromX));\r\n            if (position.from.minY !== undefined)\r\n                fromY = Math.max(fromY, math.Number.relation(position.from.minY, sizeFrom.height, fromY));\r\n            if (position.from.maxY !== undefined)\r\n                fromY = Math.min(fromY, math.Number.relation(position.from.maxY, sizeFrom.height, fromY)); \r\n\r\n            //calc local position\r\n            var lc = Position._from.localToLocal(transform, fromX, fromY, 0, fromBox, toBox);\r\n            lc.x -= toX;\r\n            lc.y -= toY;\r\n            lc.z = 0;\r\n\r\n            var matrix = new geom.Matrix3D();\r\n            matrix.appendPositionRaw(lc.x, lc.y, 0);\r\n            matrix.append(transform.matrix);\r\n\r\n            return matrix.getPosition(ret);\r\n        }\r\n\r\n        public dispose(): void {\r\n            this.to = null;\r\n            this.from = null;\r\n            this.move = null;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/Snap.ts",
      "size": 2514,
      "sizeMinified": 1098,
      "code": "namespace jsidea.layout {\r\n    export class Snap {\r\n        public mode: ISnapMode = null;\r\n        public to: ISnapTo = {};\r\n        public grid: ISnapGrid = {};\r\n        public move: Move = new Move();\r\n\r\n        public static DEFAULT: Snap = new Snap();\r\n\r\n        private static _grid: Transform = new Transform();\r\n\r\n        public static apply(snap: Snap, element: HTMLElement): void {\r\n            var transform = Transform.create(element);\r\n            Snap.calc(snap, transform, snap.move.position);\r\n            Move.apply(snap.move, transform);\r\n        }\r\n\r\n        public static calcByElement(snap: Snap, element: HTMLElement, ret?: geom.Point3D): geom.Point3D {\r\n            return Snap.calc(snap, Transform.create(element), ret);\r\n        }\r\n\r\n        public static calc(snap: Snap, transform: Transform, ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n            if (!transform)\r\n                return;\r\n            snap = snap || Snap.DEFAULT;\r\n\r\n            var toBox = snap.to.boxModel || BoxModel.BORDER;\r\n            var gridBox = snap.grid.boxModel || BoxModel.BORDER;\r\n            var gridElement = snap.grid.element || transform.element.ownerDocument.documentElement;\r\n\r\n            var grid = Snap._grid.update(gridElement);\r\n            var mode = snap.mode || SnapMode.BASIC;\r\n\r\n            //transform box-models of \"to\"\r\n            var sizeTo = transform.size.bounds(toBox);\r\n            var toX: number = math.Number.relation(snap.to.x, sizeTo.width, 0) + math.Number.relation(snap.to.offsetX, sizeTo.width, 0);\r\n            var toY: number = math.Number.relation(snap.to.y, sizeTo.height, 0) + math.Number.relation(snap.to.offsetY, sizeTo.height, 0);\r\n\r\n            var off = new geom.Point3D(toX, toY);\r\n            var point = transform.localToLocalPoint(grid, off, toBox, gridBox);\r\n\r\n            //snap in actual coordinate-system\r\n            mode.transform(snap, transform, point);\r\n\r\n            var lc = grid.localToLocalPoint(transform, point, gridBox, toBox);\r\n            lc.sub(off);\r\n            lc.z = 0;\r\n\r\n            var matrix = new geom.Matrix3D();\r\n            matrix.appendPosition(lc);\r\n            matrix.append(transform.matrix);\r\n\r\n            return matrix.getPosition(ret);\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/SnapMode/Basic.ts",
      "size": 760,
      "sizeMinified": 308,
      "code": "namespace jsidea.layout.SnapMode {\r\n    class BasicSnapMode implements ISnapMode {\r\n        public transform(snap: Snap, transform: Transform, point: geom.Point3D): void {\r\n            point.x = math.Number.roundTo(point.x, 60);\r\n            point.y = math.Number.roundTo(point.y, 60);\r\n        }\r\n    }\r\n    export var BASIC: ISnapMode = new BasicSnapMode();\r\n}"
    },
    {
      "name": "src/jsidea/layout/StyleNode.ts",
      "size": 16552,
      "sizeMinified": 6633,
      "code": "namespace jsidea.layout {\r\n    export class StyleNode {\r\n        public static create(element: HTMLElement): IStyleNode {\r\n            if (!element)\r\n                return null;\r\n            return StyleNode.extractStyleChain(element);\r\n        }\r\n\r\n        private static extractStyleChain(element: HTMLElement): IStyleNode {\r\n            var body = element.ownerDocument.body;\r\n            var html = element.ownerDocument.documentElement;\r\n            \r\n            //collect from child to root\r\n            var nodes: IStyleNode[] = [];\r\n            while (element) {\r\n                var style = window.getComputedStyle(element);\r\n                var node: IStyleNode = <any>{};\r\n                node.element = element;\r\n                node.first = null;\r\n                node.child = null;\r\n                node.parent = null;\r\n                node.last = null;\r\n                node.isTransformed = style.transform != \"none\";\r\n                node.isTransformed3D = style.transform.indexOf(\"matrix3d\") >= 0;\r\n                node.isPreserved3d = style.transformStyle == \"preserve-3d\";\r\n                node.isScrollable = style.overflow != \"visible\";\r\n                node.depth = 0;\r\n                node.perspective = 0;\r\n                node.isHTML = element == html;\r\n                node.isBody = element == body;\r\n                node.style = style;\r\n                node.isForced2D = false;\r\n                \r\n                //maybe its not needed\r\n                if (system.Browser.isInternetExplorer)\r\n                    node.isPreserved3d = false;\r\n                \r\n                //webkit ignores perspective set on scroll elements\r\n                node.perspective = (system.Engine.isWebKit && node.isTransformed && node.isScrollable) ? 0 : math.Number.parse(style.perspective, 0);\r\n\r\n                (<any>element)._node = <IStyleNode>node;\r\n                nodes.push(node);\r\n                element = element.parentElement;\r\n            }\r\n\r\n            var first = nodes[nodes.length - 1];\r\n            var last = nodes[0];\r\n            var depth = 0;\r\n            node = first;\r\n            while (node) {\r\n                node.first = first;\r\n                node.last = last;\r\n                node.depth = depth++;\r\n                node.child = nodes[(nodes.length - node.depth) - 1];\r\n                node.parent = nodes[(nodes.length - node.depth) + 1];\r\n                node.isForced2D = this.getIsForced2D(node);\r\n                node = node.child;\r\n            }\r\n\r\n            var chain = last;\r\n            \r\n            //run from root to child\r\n            //this should prevent that if the parent element\r\n            //has the webkit-bug and an element changed\r\n            //from static to relative position\r\n            //the offsets of the possible children are wrong\r\n            //and this order prevents it (root to child)\r\n            var isTransformedChild = false;\r\n            var isPreserved3dChild = false;\r\n            var isFixedChild = false;\r\n            var isPerspectiveChild = false;\r\n            var node = <IStyleNode>chain.first;\r\n            while (node) {\r\n                var style = node.style;\r\n                var element = node.element;\r\n\r\n                node.isPreserved3dChild = isPreserved3dChild;\r\n                node.isPreserved3dOrPerspective = node.isPreserved3d || (node.perspective > 0);\r\n                node.isPerspectiveChild = isPerspectiveChild;\r\n                node.isFixedZombie = false;\r\n                node.isFixed = style.position == \"fixed\";\r\n                node.isFixedChild = isFixedChild;\r\n                node.isRelative = style.position == \"relative\";\r\n                node.isAbsolute = style.position == \"absolute\";\r\n                node.isStatic = style.position == \"static\";\r\n                node.isBorderBox = style.boxSizing == \"border-box\";\r\n                node.offsetLeft = element.offsetLeft;\r\n                node.offsetTop = element.offsetTop;\r\n\r\n                if (system.Engine.isWebKit) {\r\n                    if (node.isHTML) {\r\n                        node.offsetLeft = node.element.ownerDocument.body.offsetLeft;\r\n                        node.offsetTop = node.element.ownerDocument.body.offsetTop;\r\n                    }\r\n                    else if (node.isBody) {\r\n                        node.offsetLeft = 0;\r\n                        node.offsetTop = 0;\r\n                    }\r\n                }\r\n\r\n                node.clientLeft = element.clientLeft;\r\n                node.clientTop = element.clientTop;\r\n                node.isTransformedChild = isTransformedChild;\r\n                node.offsetParentRaw = node.element.offsetParent ? (<any>node.element.offsetParent)._node : null;\r\n                node.isSticked = this.getIsSticked(node);\r\n                node.isFixedZombie = node.isFixed && !node.isSticked;\r\n                node.isStickedChild = this.getIsStickedChild(node);\r\n                node.offsetParent = this.getOffsetParent(node);\r\n                node.parentScroll = system.Browser.isFirefox ? this.getParentScrollFirefox(node) : this.getParentScroll(node);\r\n                node.scrollOffset = this.getScrollOffset(node);\r\n                node.offset = this.getOffset(node);\r\n                node.offsetUnscrolled = new geom.Point2D(node.offset.x + node.scrollOffset.x, node.offset.y + node.scrollOffset.y);\r\n                node.position = this.getPosition(node);\r\n                \r\n                //if the element has transform\r\n                //the following elements are in transformed-context\r\n                if (!isTransformedChild && node.isTransformed)\r\n                    isTransformedChild = true;\r\n\r\n                if (!isFixedChild && node.isFixed)\r\n                    isFixedChild = true;\r\n\r\n                if (!isPreserved3dChild && node.isPreserved3d)\r\n                    isPreserved3dChild = true;\r\n\r\n                if (!isPerspectiveChild && node.perspective > 0)\r\n                    isPerspectiveChild = true;\r\n\r\n                node = node.child;\r\n            }\r\n\r\n            return <IStyleNode>chain;\r\n        }\r\n\r\n        //returns the local position the direct parent\r\n        private static getPosition(node: IStyleNode, ret: geom.Point2D = new geom.Point2D()): geom.Point2D {\r\n            if (node.isSticked || !node.parent)\r\n                return ret.setTo(node.offset.x, node.offset.y);\r\n            return ret.setTo(node.offset.x - node.parent.offset.x, node.offset.y - node.parent.offset.y);\r\n        }\r\n\r\n        private static getOffsetParent(node: IStyleNode): IStyleNode {\r\n            //            if (system.Caps.isFirefox)\r\n            //                return node.element.offsetParent ? node.element.offsetParent._node : null;\r\n\r\n            //if its forced to have another parent\r\n            if (node.isFixedZombie) {\r\n                while (node = node.parent) {\r\n                    if (node.isBody || node.isSticked)\r\n                        return node;\r\n\r\n                    if (node.isStatic) {\r\n                        if (node.isTransformed || node.isPreserved3dOrPerspective)\r\n                            return node;\r\n                        else\r\n                            continue;\r\n                    }\r\n                    \r\n                    //that is the trick\r\n                    //if the element itself is wrongyl-fixed\r\n                    //than this could not be the offset\r\n                    if ((node.isFixedZombie || !node.isPerspectiveChild) && !node.isTransformed && !node.isPreserved3dOrPerspective) {\r\n                        continue;\r\n                    }\r\n\r\n                    return node;\r\n                }\r\n                return null;\r\n            }\r\n\r\n            if (!node || node.isBody || node.isSticked)\r\n                return null;\r\n            while (node = node.parent) {\r\n                if (!node.isStatic || node.isTransformed || node.isPreserved3dOrPerspective || node.isSticked) {\r\n                    return node;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        private static getParentScroll(node: IStyleNode): IStyleNode {\r\n            //important: if the node is really sticked, then there could not be any scrolling\r\n            if (!node || node.isSticked || !node.parent)\r\n                return null;\r\n\r\n            //TODO: FIND THE BUG\r\n            //if its forced to have another parent\r\n            if (node.isFixedZombie)\r\n                return node.offsetParent;\r\n\r\n            var excludeStaticParent = node.isAbsolute;\r\n            while ((node = node.parent) && node.parent) {\r\n                if (node.isBody || node.isSticked)\r\n                    return node;\r\n                if (excludeStaticParent && (node.isStatic && !node.isTransformed))\r\n                    continue;\r\n                return node;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        private static getParentScrollFirefox(node: IStyleNode): IStyleNode {\r\n            //important: if the node is really sticked, then there could not be any scrolling\r\n            if (!node || node.isSticked || !node.parent)\r\n                return null;\r\n\r\n            //TODO: FIND THE BUG\r\n            //if its forced to have another parent\r\n            if (node.isFixedZombie)\r\n                return node.offsetParent;\r\n\r\n            var excludeStaticParent = node.isAbsolute;\r\n            while ((node = node.parent) && node.parent) {\r\n                if (node.isBody || node.isSticked)\r\n                    return node;\r\n                if (excludeStaticParent && (node.isStatic && !node.isTransformedChild))\r\n                    continue;\r\n                return node;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        private static getIsStickedChild(node: IStyleNode): boolean {\r\n            while (node) {\r\n                if (node.isSticked)\r\n                    return true;\r\n                node = node.parent;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static getIsSticked(node: IStyleNode): boolean {\r\n            //just skip if the element itself has not fixed\r\n            if (!node.isFixed)\r\n                return false;\r\n            \r\n            //ie does it right\r\n            if (system.Browser.isInternetExplorer || system.Browser.isEdge)\r\n                return node.isFixed && !(node.isPerspectiveChild || node.isPreserved3dOrPerspective);\r\n\r\n            while (node = node.parent) {\r\n                if (node.isTransformed || node.isPreserved3dOrPerspective)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        //if you subtract the scroll from the accumlated/summed offset\r\n        //you get the real offset to window (initial-containing-block)\r\n        private static getScrollOffset(node: IStyleNode, ret: geom.Point2D = new geom.Point2D()): geom.Point2D {\r\n            if (!node || !node.parent)\r\n                return ret;\r\n            \r\n            //add scroll value only if reference of the element is the window not the body\r\n            if (node.isStickedChild) {\r\n                if (system.Engine.isWebKit) {\r\n                    ret.x -= node.element.ownerDocument.body.scrollLeft;\r\n                    ret.y -= node.element.ownerDocument.body.scrollTop;\r\n                }\r\n                else {\r\n                    ret.x -= node.element.ownerDocument.documentElement.scrollLeft;\r\n                    ret.y -= node.element.ownerDocument.documentElement.scrollTop;\r\n                }\r\n            }\r\n\r\n            //skip body \r\n            //the body scroll is only needed for elemente which are fixed to window\r\n            //so this value is added add the getOffset-function\r\n            while ((node = node.parentScroll) && !node.isBody) {\r\n                ret.x += node.element.scrollLeft;\r\n                ret.y += node.element.scrollTop;\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        private static getOffset(node: IStyleNode, ret: geom.Point2D = new geom.Point2D()): geom.Point2D {\r\n            ret.x = 0;\r\n            ret.y = 0;\r\n\r\n            //the offset of void/null is 0 0\r\n            if (!node)\r\n                return ret;\r\n\r\n            ret.x -= node.scrollOffset.x;\r\n            ret.y -= node.scrollOffset.y;\r\n            \r\n            //if it is really fixed, then just make it fast\r\n            //wow, and the offsets are correct\r\n            //if the element is really fixed\r\n            if (node.isSticked) {\r\n                this.addCorrectOffset(node, ret);\r\n                return ret;\r\n            }\r\n\r\n            var leafNode = node;\r\n            while (node) {\r\n                //for webkit (if there is a wrong offserParent set,\r\n                //then the offsets are also wrong... arghhh)\r\n                //correct them here\r\n                this.addCorrectOffset(node, ret);\r\n                if (!node.offsetParentRaw)\r\n                    break;\r\n                node = node.offsetParent;\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        private static getIsForced2D(node: IStyleNode): boolean {\r\n            //ie11 has no \"working\" preserve-3d, but window.getComputedStyle includes the preserve-3d value? \r\n            if (system.Browser.isInternetExplorer)\r\n                return false;\r\n            \r\n            //in any case, if an element has only 2d-transforms or its the document-root item\r\n            //the transform can be accumulated to the parent transform\r\n            if (node.isBody || !node.isTransformed3D)\r\n                return false;\r\n\r\n            //tricky stuff: only firefox does reflect/compute the \"correct\" transformStyle value.\r\n            //Firefox does NOT reflect the \"grouping\"-overrides and this is how its concepted.\r\n            //But what about the \"opacity\"-property. Opacity does not override the preserve-3d (not always, webkit does under some conditions).\r\n            //http://dev.w3.org/csswg/css-transforms/#grouping-property-values\r\n            if (!node.parent.isPreserved3d && node.parent.perspective == 0)\r\n                return true;\r\n\r\n            if (node.parent.isScrollable)\r\n                return true;\r\n\r\n            return false;\r\n        }\r\n\r\n        private static addCorrectOffset(node: IStyleNode, ret: geom.Point2D = new geom.Point2D()): geom.Point2D {\r\n            if (!node)\r\n                return ret;\r\n\r\n            ret.x += node.offsetLeft;\r\n            ret.y += node.offsetTop;\r\n\r\n            if (system.Engine.isWebKit) {\r\n                this.getCorrectOffsetWebkit(node, ret);\r\n            } else if (system.Browser.isFirefox) {\r\n                this.getCorrectOffsetFirefox(node, ret);\r\n            } else if (system.Browser.isInternetExplorer) {\r\n                this.getCorrectOffsetInternetExplorer(node, ret);\r\n            } else if (system.Browser.isEdge) {\r\n                this.getCorrectOffsetEdge(node, ret);\r\n            }\r\n\r\n            return ret;\r\n        }\r\n\r\n        private static getCorrectOffsetEdge(node: IStyleNode, ret: geom.Point2D): geom.Point2D {\r\n            if (!node || !node.offsetParent || node.isBody)\r\n                return ret;\r\n\r\n            if (node.offsetParent.element != node.element.offsetParent) {\r\n                //coming soon...\r\n                return ret;\r\n            }\r\n\r\n            ret.x += node.offsetParent.clientLeft;\r\n            ret.y += node.offsetParent.clientTop;\r\n        }\r\n\r\n        private static getCorrectOffsetInternetExplorer(node: IStyleNode, ret: geom.Point2D): geom.Point2D {\r\n            if (!node || !node.offsetParent || node.isBody)\r\n                return ret;\r\n\r\n            //bla bla ... if an element ist position \"fixed\" the offsetParent is always zero ....\r\n            //in perspective the getBoundingClientRect() will fail too\r\n            if (node.offsetParent.element != node.element.offsetParent) {\r\n                //UNSOLVABLE if wrong\r\n                return ret;\r\n            }\r\n\r\n            ret.x += node.offsetParent.clientLeft;\r\n            ret.y += node.offsetParent.clientTop;\r\n        }\r\n\r\n        private static getCorrectOffsetFirefox(node: IStyleNode, ret: geom.Point2D): geom.Point2D {\r\n            //no node no value\r\n            if (!node)\r\n                return ret;\r\n\r\n            if (!node.offsetParent) {\r\n                if ((node.isStatic || node.isRelative) && !node.isHTML) {\r\n                    ret.x += node.element.ownerDocument.body.clientLeft;\r\n                    ret.y += node.element.ownerDocument.body.clientTop;\r\n                }\r\n                return ret;\r\n            }\r\n\r\n            if (!node.offsetParent.isBorderBox) {\r\n                ret.x += node.offsetParent.clientLeft;\r\n                ret.y += node.offsetParent.clientTop;\r\n            }\r\n\r\n            if (\r\n                (node.isAbsolute || node.isFixedZombie)\r\n                && node.offsetParent.isScrollable\r\n            ) {\r\n                ret.x += node.offsetParent.clientLeft;\r\n                ret.y += node.offsetParent.clientTop;\r\n            }\r\n            \r\n            //if there is no bug to fix\r\n            if (node.offsetParent.element == node.element.offsetParent)\r\n                return ret;\r\n            \r\n            //this should not happen at all\r\n            console.warn(\"The given offsetParent is maybe wrong.\");\r\n\r\n            return ret;\r\n        }\r\n\r\n        private static getCorrectOffsetWebkit(node: IStyleNode, ret: geom.Point2D): geom.Point2D {\r\n            if (!node || !node.offsetParent)\r\n                return ret;\r\n\r\n            //Why is chrome does not keep care of css-transform on static elements\r\n            //when it comes to the right offsetParent and the offsetTop/offsetLeft values\r\n            if (node.offsetParentRaw != node.offsetParent) {\r\n                //console.warn(\"The given offsetParent is maybe wrong.\");\r\n                \r\n                //trivial if there is a missing offsetParentRaw\r\n                //than just add the already calculated \"correct\" offset here\r\n                //that is possible because the calculation runs from body -> root\r\n                //the offset sum calculation stops for webkit if the \r\n                //parentOffsetRaw is null\r\n                //so we have to return the full-offset\r\n                if (!node.offsetParentRaw) {\r\n                    ret.x += node.offsetParent.offsetUnscrolled.x;\r\n                    ret.y += node.offsetParent.offsetUnscrolled.y;\r\n                }\r\n                else {\r\n                    //do nothing if...\r\n                    if (node.isBody || node.isAbsolute || node.offsetParent.isBody) {\r\n                    }\r\n                    //we need to re-calc the offset\r\n                    //just subtract the difference of the wrong-offset and correct-offset\r\n                    else {\r\n                        //offset without scroll\r\n                        //the scroll value is already applied or will be applied\r\n                        //for the target node\r\n                        ret.x -= node.offsetParent.offsetUnscrolled.x - node.offsetParentRaw.offsetLeft;\r\n                        ret.y -= node.offsetParent.offsetUnscrolled.y - node.offsetParentRaw.offsetTop;\r\n                    }\r\n                }\r\n            }\r\n            else if (node.offsetParent) {\r\n                if (node.offsetParent.isBody || node.isFixedZombie) {\r\n                }\r\n                else if (!node.offsetParent.isStatic) {\r\n                    ret.x += node.offsetParent.clientLeft;\r\n                    ret.y += node.offsetParent.clientTop;\r\n                }\r\n            }\r\n\r\n            return ret;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/Transform.ts",
      "size": 6747,
      "sizeMinified": 3303,
      "code": "namespace jsidea.layout {\r\n    export class Transform {\r\n        public element: HTMLElement = null;\r\n        public toBox: IBoxModel = BoxModel.BORDER;\r\n        public fromBox: IBoxModel = BoxModel.BORDER;\r\n        public matrix: geom.Matrix3D = new geom.Matrix3D();\r\n        public sceneTransform: geom.Matrix3D = new geom.Matrix3D();\r\n        public inverseSceneTransform: geom.Matrix3D = new geom.Matrix3D();\r\n        public size: Box = new Box();\r\n        \r\n        constructor(element?: HTMLElement, mode?: ITransformMode) {\r\n            if (element)\r\n                this.update(element, mode);\r\n        }\r\n\r\n        public static create(element?: HTMLElement, mode?: ITransformMode): Transform {\r\n            return new Transform(element, mode);\r\n        }\r\n\r\n        public update(element?: HTMLElement, mode?: ITransformMode): Transform {\r\n            if (!element)\r\n                return this.clear();\r\n\r\n            this.element = element;\r\n\r\n            //if no mode is given, then\r\n            //use the most lightweight mode\r\n            mode = mode || TransformMode.RECTANGLE;\r\n            \r\n            //FORCE FOR TESTING\r\n            mode = TransformMode.PERSPECTIVE;\r\n\r\n            var style = window.getComputedStyle(element);\r\n            this.size.update(element, style);\r\n            this.matrix.setCSS(style.transform);\r\n            this.sceneTransform.identity();\r\n            mode.extract(this, this.sceneTransform);\r\n            this.sceneTransform.invert(this.inverseSceneTransform);\r\n\r\n            return this;\r\n        }\r\n\r\n        public append(matrix: geom.Matrix3D): Transform {\r\n            matrix = matrix.clone();\r\n\r\n            this.matrix.append(matrix);\r\n            this.sceneTransform.append(matrix);\r\n            this.sceneTransform.invert(this.inverseSceneTransform);\r\n\r\n            return this;\r\n        }\r\n\r\n        public prepend(matrix: geom.Matrix3D): Transform {\r\n            matrix = matrix.clone();\r\n\r\n            this.matrix.prepend(matrix);\r\n            this.sceneTransform.prepend(matrix);\r\n            this.sceneTransform.invert(this.inverseSceneTransform);\r\n\r\n            return this;\r\n        }\r\n\r\n        public clear(): Transform {\r\n            this.element = null;\r\n            this.size.clear();\r\n            this.matrix.identity();\r\n\r\n            return this;\r\n        }\r\n\r\n        public localToLocalPoint(\r\n            to: Transform,\r\n            pt: geom.Point3D,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            return this.localToLocal(to, pt.x, pt.y, pt.z, fromBox, toBox, ret);\r\n        }\r\n\r\n        public localToLocalQuad(\r\n            to: Transform,\r\n            quad: geom.Quad,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Quad = new geom.Quad()): geom.Quad {\r\n\r\n            this.localToLocalPoint(to, quad.p1, fromBox, toBox, ret.p1);\r\n            this.localToLocalPoint(to, quad.p2, fromBox, toBox, ret.p2);\r\n            this.localToLocalPoint(to, quad.p3, fromBox, toBox, ret.p3);\r\n            this.localToLocalPoint(to, quad.p4, fromBox, toBox, ret.p4);\r\n            return ret;\r\n        }\r\n\r\n        public localToLocal(\r\n            to: Transform,\r\n            x: number,\r\n            y: number,\r\n            z: number = 0,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            ret.setTo(x, y, z);\r\n            var gl = this.localToGlobalPoint(ret, fromBox, BoxModel.BORDER, ret);\r\n            return to.globalToLocalPoint(gl, BoxModel.BORDER, toBox, ret);\r\n        }\r\n\r\n        public globalToLocalPoint(\r\n            point: geom.Point3D,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            return this.globalToLocal(point.x, point.y, point.z, fromBox, toBox, ret);\r\n        }\r\n\r\n        public globalToLocalQuad(\r\n            quad: geom.Quad,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Quad = new geom.Quad()): geom.Quad {\r\n\r\n            this.globalToLocalPoint(quad.p1, fromBox, toBox, ret.p1);\r\n            this.globalToLocalPoint(quad.p2, fromBox, toBox, ret.p2);\r\n            this.globalToLocalPoint(quad.p3, fromBox, toBox, ret.p3);\r\n            this.globalToLocalPoint(quad.p4, fromBox, toBox, ret.p4);\r\n            return ret;\r\n        }\r\n\r\n        public globalToLocal(\r\n            x: number,\r\n            y: number,\r\n            z: number = 0,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            ret.setTo(x, y, z);\r\n            \r\n            //apply box model transformations\r\n            this.size.transform(ret, fromBox || this.fromBox, BoxModel.BORDER);\r\n            \r\n            //unproject from parent to child\r\n            this.inverseSceneTransform.unproject(ret, ret);\r\n\r\n            //apply box model transformations\r\n            this.size.transform(ret, BoxModel.BORDER, toBox || this.toBox);\r\n\r\n            return ret;\r\n        }\r\n\r\n        public localToGlobalPoint(\r\n            point: geom.Point3D,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            return this.localToGlobal(point.x, point.y, point.z, fromBox, toBox, ret);\r\n        }\r\n\r\n        public localToGlobalQuad(\r\n            quad: geom.Quad,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Quad = new geom.Quad()): geom.Quad {\r\n            this.localToGlobalPoint(quad.p1, fromBox, toBox, ret.p1);\r\n            this.localToGlobalPoint(quad.p2, fromBox, toBox, ret.p2);\r\n            this.localToGlobalPoint(quad.p3, fromBox, toBox, ret.p3);\r\n            this.localToGlobalPoint(quad.p4, fromBox, toBox, ret.p4);\r\n            return ret;\r\n        }\r\n\r\n        public localToGlobal(\r\n            x: number,\r\n            y: number,\r\n            z: number = 0,\r\n            fromBox?: IBoxModel,\r\n            toBox?: IBoxModel,\r\n            ret: geom.Point3D = new geom.Point3D()): geom.Point3D {\r\n\r\n            ret.setTo(x, y, z);\r\n            \r\n            //apply from-box model transformations\r\n            this.size.transform(ret, fromBox || this.fromBox, BoxModel.BORDER);            \r\n            \r\n            //project from child to parent\r\n            this.sceneTransform.project(ret, ret);\r\n            \r\n            //apply to-box model transformations\r\n            this.size.transform(ret, BoxModel.BORDER, toBox || this.toBox);\r\n\r\n            return ret;\r\n        }\r\n\r\n        public dispose(): void {\r\n            this.element = null;\r\n            this.toBox = null;\r\n            this.fromBox = null;\r\n            this.matrix = null;\r\n            this.size = null;\r\n            this.sceneTransform = null;\r\n            this.inverseSceneTransform = null;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/layout/TransformMode/Perspective.ts",
      "size": 3206,
      "sizeMinified": 1213,
      "code": "namespace jsidea.layout.TransformMode {\r\n    class Perspective implements ITransformMode {\r\n        private static _matrix: geom.Matrix3D = new geom.Matrix3D();\r\n        public extract(transform: Transform, matrix: geom.Matrix3D): void {\r\n            var element = transform.element;\r\n            var node = layout.StyleNode.create(element);\r\n            \r\n            //accumulate matrix\r\n            while (node) {\r\n                this.extractMatrix(node, matrix);\r\n                if (node && node.isSticked)\r\n                    break;\r\n                node = node.parent;\r\n            }\r\n        }\r\n\r\n        private extractMatrix(node: layout.IStyleNode, matrix: geom.Matrix3D = null): geom.Matrix3D {\r\n            if (!matrix)\r\n                matrix = new geom.Matrix3D();\r\n            if (!node)\r\n                return matrix;\r\n\r\n            var element: HTMLElement = node.element;\r\n            var style: CSSStyleDeclaration = node.style;\r\n            \r\n            //------\r\n            //transform (including transformOrigin)\r\n            //------\r\n            if (node.isTransformed) {\r\n                var origin = style.transformOrigin ? style.transformOrigin.split(\" \") : [];\r\n                var originX = math.Number.relation(origin[0], element.offsetWidth, element.offsetWidth * 0.5);\r\n                var originY = math.Number.relation(origin[1], element.offsetHeight, element.offsetHeight * 0.5);\r\n                var originZ = math.Number.parse(origin[2], 0);\r\n\r\n                matrix.appendPositionRaw(-originX, -originY, -originZ);\r\n                //if the parent is flattened (not preserve-3d) \r\n                //then just reduce it to the 2D-plane\r\n                matrix.appendCSS(style.transform, node.isForced2D);\r\n                matrix.appendPositionRaw(originX, originY, originZ);\r\n            }\r\n            \r\n            //------\r\n            //local position\r\n            //------\r\n            //append the position to the transform-matrix\r\n            //position is relative to the direct parent\r\n            //not the offsetParent\r\n            matrix.appendPositionRaw(node.position.x, node.position.y, 0);\r\n            \r\n            //-------\r\n            //perspective/focalLength/nearFarDistance/frustumLength or whatever you wanna call it\r\n            //-------\r\n            if (node.parent && node.parent.perspective) {\r\n                var perspective = node.parent.perspective;\r\n                var parentStyle: CSSStyleDeclaration = node.parent.style;\r\n                var perspectiveOrigin = parentStyle.perspectiveOrigin.split(\" \");\r\n                var perspectiveOriginX = math.Number.relation(perspectiveOrigin[0], element.parentElement.offsetWidth, 0);\r\n                var perspectiveOriginY = math.Number.relation(perspectiveOrigin[1], element.parentElement.offsetHeight, 0);\r\n\r\n                matrix.appendPositionRaw(-perspectiveOriginX, -perspectiveOriginY, 0);\r\n                matrix.appendPerspective(perspective);\r\n                matrix.appendPositionRaw(perspectiveOriginX, perspectiveOriginY, 0);\r\n            }\r\n\r\n            return matrix;\r\n        }\r\n    }\r\n\r\n    export var PERSPECTIVE: ITransformMode = new Perspective();\r\n}"
    },
    {
      "name": "src/jsidea/layout/TransformMode/Planar.ts",
      "size": 2947,
      "sizeMinified": 1023,
      "code": "namespace jsidea.layout.TransformMode {\r\n    class Planar implements ITransformMode {\r\n        public extract(transform: Transform, matrix: geom.Matrix3D): void {\r\n            var element = transform.element;\r\n            var globalBounds = geom.Rect2D.getBounds(element);\r\n                        \r\n            //collect elements\r\n            var elements: HTMLElement[] = [];\r\n            var target = element;\r\n            while (target) {\r\n                elements.push(target);\r\n                target = target.parentElement;\r\n            }\r\n            elements.reverse();\r\n\r\n            //accumulate matrix\r\n            var parentStyle: CSSStyleDeclaration = null;\r\n            for (var e of elements) {\r\n                var style = window.getComputedStyle(e);\r\n                var isForced2D = this.getIsForced2D(e, style, parentStyle);\r\n                matrix.prependCSS(style.transform, isForced2D);\r\n                parentStyle = style;\r\n            }\r\n            \r\n            //transform to fit\r\n            var localBounds = matrix.bounds(0, 0, element.offsetWidth, element.offsetHeight);\r\n            var scX = globalBounds.width / localBounds.width;\r\n            var scY = globalBounds.height / localBounds.height;\r\n            matrix.appendScaleRaw(scX, scY, 1);\r\n            matrix.appendPositionRaw(-localBounds.x, -localBounds.y, 0);\r\n            matrix.appendPositionRaw(globalBounds.x, globalBounds.y, 0);\r\n        }\r\n\r\n        //return true if the elements computed transform-style is \"wrongly\" set to an matrix3d but its actually a flattened one\r\n        private getIsForced2D(element: HTMLElement, style: CSSStyleDeclaration, parentStyle: CSSStyleDeclaration): boolean {\r\n            if (!element.parentElement || system.Browser.isInternetExplorer || element.tagName == \"body\" || !(style.transform != \"none\"))\r\n                return false;\r\n\r\n            var perspective = math.Number.parse(parentStyle.perspective, 0);\r\n            if (system.Engine.isWebKit) {\r\n                var isScrollable = parentStyle.overflow != \"visible\";\r\n                var isTransformed = parentStyle.transform != \"none\";\r\n                if (isTransformed && isScrollable)\r\n                    perspective = 0;\r\n            }\r\n            var isPreserved3d = parentStyle.transformStyle == \"preserve-3d\";\r\n            if ((!isPreserved3d && perspective == 0) || parentStyle.overflow != \"visible\")\r\n                return true;\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    export var PLANAR: ITransformMode = new Planar();\r\n}"
    },
    {
      "name": "src/jsidea/layout/TransformMode/Rectangle.ts",
      "size": 794,
      "sizeMinified": 322,
      "code": "namespace jsidea.layout.TransformMode {\r\n    class Rectangle implements ITransformMode {\r\n        public extract(transform: Transform, matrix: geom.Matrix3D): void {\r\n            var globalBounds = geom.Rect2D.getBounds(transform.element);\r\n            matrix.appendPositionRaw(globalBounds.x, globalBounds.y, 0);\r\n        }\r\n    }\r\n\r\n    export var RECTANGLE: ITransformMode = new Rectangle();\r\n}"
    },
    {
      "name": "src/jsidea/layout/TransformMode/Test.ts",
      "size": 1595,
      "sizeMinified": 599,
      "code": "namespace jsidea.layout.TransformMode {\r\n    class Test implements ITransformMode {\r\n        public extract(transform: Transform, matrix: geom.Matrix3D): void {\r\n            var element = transform.element;\r\n            var globalBounds = geom.Rect2D.getBounds(element);\r\n            while (element) {\r\n                matrix.append(geom.Matrix3D.create(element));\r\n                element = element.parentElement;\r\n            }\r\n            \r\n            //if perspective of preserve-3d is on the get getBoundingClientRect\r\n            //we need to scale it\r\n            element = transform.element;\r\n            var localBounds = matrix.bounds(0, 0, element.offsetWidth, element.offsetHeight);\r\n            var scX = globalBounds.width / localBounds.width;\r\n            var scY = globalBounds.height / localBounds.height;\r\n            matrix.appendScaleRaw(scX, scY, 1);\r\n\r\n            //re-offset\r\n            element = transform.element\r\n            var localBounds = matrix.bounds(0, 0, element.offsetWidth, element.offsetHeight);\r\n            matrix.appendPositionRaw(-localBounds.x, -localBounds.y, 0);\r\n            matrix.appendPositionRaw(globalBounds.x, globalBounds.y, 0);\r\n        }\r\n    }\r\n    export var TEST: ITransformMode = new Test();\r\n}\r\n"
    },
    {
      "name": "src/jsidea/math/ILimit.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.math {\r\n    export interface ILimit {\r\n        minX?: any;\r\n        maxX?: any;\r\n        minY?: any;\r\n        maxY?: any;\r\n        minZ?: any;\r\n        maxZ?: any;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/math/Number.ts",
      "size": 4768,
      "sizeMinified": 1673,
      "code": "namespace jsidea.math {\r\n    export class Number {\r\n\r\n        public static RAD_TO_DEG: number = 180 / Math.PI;\r\n        public static DEG_TO_RAD: number = Math.PI / 180;\r\n        public static BYTE_TO_KILOBYTE: number = 0.000976563;\r\n        public static BYTE_TO_MB: number = 9.53674e-7;\r\n        public static BYTE_TO_GIGABYTE: number = 9.31323e-10;\r\n\r\n        public static precision(num: number, precesion: number): number {\r\n            return Math.round(num * precesion) / precesion;\r\n        }\r\n\r\n        public static relation(value: any, relativeSize: number, defaultValue: number): number {\r\n            if (typeof value == \"number\") {\r\n                return value;\r\n            }\r\n            else if (typeof value == \"string\") {\r\n                value = (<string>value).trim().toLowerCase();\r\n                if (value.indexOf(\"%\") > 0) {\r\n                    return (Number.parse(value.replace(\"%\", \"\"), defaultValue) / 100) * relativeSize;\r\n                }\r\n                else if (value.indexOf(\"px\") > 0 || value.indexOf(\"pt\") > 0) {\r\n                    return Number.parse(value.replace(\"px\", \"\"), defaultValue);\r\n                }\r\n                else if (value.indexOf(\"vw\") > 0) {\r\n                    return (Number.parse(value.replace(\"vw\", \"\"), defaultValue) / 100) * window.innerWidth;\r\n                }\r\n                else if (value.indexOf(\"vh\") > 0) {\r\n                    return (Number.parse(value.replace(\"vh\", \"\"), defaultValue) / 100) * window.innerHeight;\r\n                }\r\n                else if (value.indexOf(\"vm\") > 0) {\r\n                    return (Number.parse(value.replace(\"vm\", \"\"), defaultValue) / 100) * Math.min(window.innerWidth, window.innerHeight);\r\n                }\r\n                else if (value.indexOf(\"em\") > 0) {\r\n                    return Number.parse(value.replace(\"em\", \"\"), defaultValue);\r\n                }\r\n                else if (value == \"top\" || value == \"left\")\r\n                    return 0;\r\n                else if (value == \"center\" || value == \"middle\")\r\n                    return relativeSize * 0.5;\r\n                else if (value == \"bottom\" || value == \"right\")\r\n                    return relativeSize;\r\n                return defaultValue;\r\n            }\r\n            return defaultValue;\r\n        }\r\n\r\n        public static parse(value: any, defaultValue: number): number {\r\n            value = parseFloat(value);\r\n            if (isNaN(value))\r\n                return defaultValue;\r\n            return value;\r\n        }\r\n\r\n        public static clamp(value: number, min: number, max: number): number {\r\n            if (min > max) {\r\n                var tmp = max;\r\n                max = min;\r\n                min = tmp;\r\n            }\r\n            return (value < min) ? min : ((value > max) ? max : value);\r\n        }\r\n\r\n        public static roundTo(value: number, mod: number): number {\r\n            var r: number = value % mod;\r\n            return (r < (mod * 0.5)) ? value - r : value + (mod - r);\r\n        }\r\n\r\n        public static floorTo(value: number, mod: number): number {\r\n            return value - (value % mod);\r\n        }\r\n\r\n        public shortRotation(startRotation: number, endRotation: number): number {\r\n            var dif: number = (endRotation - startRotation) % 360;\r\n            if (dif != dif % 180)\r\n                dif = (dif < 0) ? dif + 360 : dif - 360;\r\n            return dif;\r\n        }\r\n\r\n        public static limits(point: geom.IPoint3DValue, limits: ILimit, width: number, height: number, depth: number = 1000): geom.IPoint3DValue {\r\n            if (limits.minX !== undefined)\r\n                point.x = Math.max(point.x, Number.relation(limits.minX, width, point.x));\r\n            if (limits.maxX !== undefined)\r\n                point.x = Math.min(point.x, Number.relation(limits.maxX, width, point.x));\r\n            if (limits.minY !== undefined)\r\n                point.y = Math.max(point.y, Number.relation(limits.minY, height, point.y));\r\n            if (limits.maxY !== undefined)\r\n                point.y = Math.min(point.y, Number.relation(limits.maxY, height, point.y));\r\n            if (limits.minZ !== undefined)\r\n                point.z = Math.max(point.z, Number.relation(limits.minZ, depth, point.z));\r\n            if (limits.maxY !== undefined)\r\n                point.z = Math.min(point.z, Number.relation(limits.maxZ, depth, point.z));\r\n            return point;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/model/Converter/Json.ts",
      "size": 756,
      "sizeMinified": 307,
      "code": "namespace jsidea.model.Converter {\r\n    class JsonParser implements IConverter {\r\n        public read(data: string): any {\r\n            return JSON.parse(data);\r\n        }\r\n\r\n        public write(data: any): string {\r\n            return JSON.stringify(data);\r\n        }\r\n    }\r\n\r\n    export var Json: IConverter = new JsonParser();\r\n}"
    },
    {
      "name": "src/jsidea/model/Dictionary.ts",
      "size": 2178,
      "sizeMinified": 971,
      "code": "namespace jsidea.model {\r\n    export class Dictonary<Key, Value> {\r\n        private _keys: Key[] = [];\r\n        private _values: Value[] = [];\r\n\r\n        constructor() {\r\n        }\r\n\r\n        public getValue(key: Key): Value {\r\n            return this._values[this._keys.indexOf(key)];\r\n        }\r\n\r\n        public setValue(key: Key, value: Value): Value {\r\n            var index = this._keys.indexOf(key);\r\n            if (index < 0) {\r\n                this._keys.push(key);\r\n                this._values.push(value);\r\n                return value;\r\n            }\r\n            this._values[index] = value;\r\n            return value;\r\n        }\r\n        \r\n        public hasKey(key: Key):boolean\r\n        {\r\n            return this._keys.indexOf(key) >= 0;    \r\n        }\r\n        \r\n        public hasValue(value: Value):boolean\r\n        {\r\n            return this._values.indexOf(value) >= 0;    \r\n        }\r\n\r\n        public clear(): void {\r\n            this._keys.splice(0, this._keys.length);\r\n            this._values.splice(0, this._values.length);\r\n        }\r\n\r\n        public removeKey(key: Key): Value {\r\n            var index = this._keys.indexOf(key);\r\n            if (index < 0)\r\n                return null;\r\n            var value: Value = this._values[index];\r\n            this._keys.splice(index, 1);\r\n            this._values.splice(index, 1);\r\n            return value;\r\n        }\r\n        \r\n        public getKeys(value: Value): Key[] {\r\n            var res:Key[] = [];\r\n            var index = 0; \r\n            while((index = this._values.indexOf(value, index)) >= 0)\r\n                res.push(this._keys[index]);\r\n            return res;\r\n        }\r\n\r\n        public length(): number {\r\n            return this._keys.length;\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/model/IConverter.ts",
      "size": 0,
      "sizeMinified": 0,
      "code": "namespace jsidea.model {\r\n    export interface IConverter {\r\n        read(data: string): any\r\n        write(data: any): string;\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/model/Loader.ts",
      "size": 1467,
      "sizeMinified": 662,
      "code": "namespace jsidea.model {\r\n    export enum LoaderMethod {\r\n        GET,\r\n        POST\r\n    }\r\n    export class Loader extends events.EventDispatcher {\r\n        private _stack: URLRequest<any>[] = [];\r\n        constructor() {\r\n            super();\r\n        }\r\n        public load(request: URLRequest<any>): void {\r\n            var ajax = new XMLHttpRequest();\r\n            ajax.onreadystatechange = (e: ProgressEvent) => {\r\n                if (ajax.readyState == 4) {\r\n                    if (ajax.status == 200) {\r\n                        //                    this.parse(JSON.parse(this._ajax.responseText));\r\n                    }\r\n                    else {\r\n                        console.log(ajax.statusText);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/model/URLRequest.ts",
      "size": 4051,
      "sizeMinified": 1565,
      "code": "namespace jsidea.model {\r\n    export enum URLMethod {\r\n        GET,\r\n        POST\r\n    }\r\n    export class URLRequest<ResponseType> extends events.EventDispatcher {\r\n        private static _parser: HTMLAnchorElement = new HTMLAnchorElement();\r\n\r\n        public method: URLMethod = URLMethod.GET;\r\n        public protocol: string;\r\n        public host: string;\r\n        public path: string;\r\n        public port: string;\r\n        public upload: any = null;\r\n        public response: ResponseType = null;\r\n        public responseText: string;\r\n        public writer: IConverter = null;\r\n        public reader: IConverter = Converter.Json;\r\n\r\n        constructor(url?: string) {\r\n            super();\r\n            if (url)\r\n                this.url = url;\r\n        }\r\n\r\n        public set url(url: string) {\r\n            var p = URLRequest._parser;\r\n            p.href = url;\r\n            this.port = p.port;\r\n            this.protocol = p.protocol;\r\n            this.host = p.host;\r\n            this.path = p.pathname;\r\n        }\r\n\r\n        public get url(): string {\r\n            var p = URLRequest._parser;\r\n            p.port = this.port;\r\n            p.protocol = this.protocol;\r\n            p.host = this.host;\r\n            p.pathname = this.path;\r\n            return p.href;\r\n        }\r\n\r\n        public send(): void {\r\n            URLRequest.send(this);\r\n        }\r\n\r\n        public static create<ResponseType>(url: string): URLRequest<ResponseType> {\r\n            return new URLRequest<ResponseType>(url);\r\n        }\r\n\r\n        private static send(request: URLRequest<any>): void {\r\n            var uploadData = request.upload;\r\n            if (uploadData && request.writer) {\r\n                try {\r\n                    uploadData = request.writer.write(request.upload);\r\n                } catch (e) {\r\n                    console.warn(e);\r\n                    request.dispatchEvent(new Event(\"error\"));\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var ajax = new XMLHttpRequest();\r\n\r\n            ajax.onreadystatechange = (e: ProgressEvent) => {\r\n                if (ajax.readyState == 4) {\r\n                    if (ajax.status == 200) {\r\n                        request.responseText = ajax.responseText;\r\n\r\n                        var responseData = request.responseText;\r\n                        if (request.reader) {\r\n                            try {\r\n                                responseData = request.reader.read(request.responseText);\r\n                            } catch (e) {\r\n                                console.warn(e);\r\n                                request.dispatchEvent(new Event(\"error\"));\r\n                                return;\r\n                            }\r\n                        }\r\n                        request.response = responseData;\r\n                        request.dispatchEvent(new Event(\"complete\"));\r\n                    }\r\n                    else {\r\n                        console.log(ajax.statusText);\r\n                    }\r\n                }\r\n            }\r\n\r\n            ajax.send(request.upload);\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/plugins/Builder.ts",
      "size": 14964,
      "sizeMinified": 6421,
      "code": "namespace jsidea.plugins {\r\n    export interface IFile {\r\n        name: string;\r\n        size: number;\r\n        code: string;\r\n        sizeMinified?: number;\r\n    }\r\n    export interface IData {\r\n        project: any;\r\n        files: IFile[];\r\n        typescript: ISymbol[];\r\n    }\r\n    export interface IReferenceData {\r\n        fullName: string;\r\n        file: string | IFile;\r\n        kind: number;\r\n        imports: any[];\r\n    }\r\n    export interface ISymbol extends IReferenceData {\r\n        ui: SymbolUI;\r\n        relations: ISymbol[];\r\n        usage: ISymbol[];\r\n        imports: ISymbol[];\r\n        usageOrder: number;\r\n        file: IFile;\r\n        name: string;\r\n        url: string;\r\n        module: IModule;\r\n        isDependent: boolean;\r\n        isChecked: boolean;\r\n    }\r\n    export interface IModule {\r\n        ui: ModuleUI;\r\n        fullName: string;\r\n        name: string;\r\n        symbols: ISymbol[];\r\n    }\r\n    type SortFunction = (a: ISymbol, b: ISymbol) => number;\r\n    export class ModuleUI {\r\n        public element: HTMLElement;\r\n        public list: HTMLDivElement;\r\n        private _data: IModule;\r\n        private _header: HTMLDivElement;\r\n        private _docs: HTMLAnchorElement;\r\n\r\n        constructor(data: IModule) {\r\n            this._data = data;\r\n\r\n            var element = document.createElement(\"div\");\r\n            element.className = \"module\";\r\n            element.id = data.fullName;\r\n            this.element = element;\r\n\r\n            var header = document.createElement(\"div\");\r\n            header.className = \"header\";\r\n            header.textContent = data.fullName.replace(\"jsidea.\", \"\");\r\n            this._header = header;\r\n\r\n            var list = document.createElement(\"div\");\r\n            list.className = \"list\";\r\n            this.list = list;\r\n\r\n            //            var docs = document.createElement(\"a\");\r\n            //            docs.className = \"docs\";\r\n            //            docs.href = data.;\r\n            //            this._docs = docs;\r\n            \r\n            element.appendChild(header);\r\n            //            header.appendChild(docs);\r\n            element.appendChild(list);\r\n\r\n            header.addEventListener(\"click\", () => {\r\n                element.classList.toggle(\"collapsed\");\r\n            });\r\n            \r\n            \r\n            //            docs.addEventListener(\"click\", () => {\r\n            //                \r\n            //            });            \r\n        }\r\n    }\r\n    export class SymbolUI {\r\n        private _data: ISymbol;\r\n        public element: HTMLElement;\r\n        private _docs: HTMLAnchorElement;\r\n\r\n        constructor(data: ISymbol) {\r\n            this._data = data;\r\n\r\n            this.element = document.createElement(\"div\");\r\n\r\n            var e = this.element;\r\n\r\n            e.className = \"symbol\";\r\n            e.id = data.fullName;\r\n            e.setAttribute(\"data-checked\", \"0\");\r\n            e.setAttribute(\"data-dependent\", \"0\");\r\n            e.setAttribute(\"data-kind\", data.kind.toString());\r\n\r\n            var chk = document.createElement(\"div\");\r\n            chk.className = \"checkbox\";\r\n            e.appendChild(chk);\r\n\r\n            var lab = document.createElement(\"div\");\r\n            lab.className = \"label\";\r\n            lab.textContent = data.name;// + \" [\" + text.Text.fileSize(data.file.size) + \" \" + text.Text.fileSize(data.file.sizeMinified) + \"]\";\r\n            //            lab.textContent = reference.name + \" [\" + reference.file.size + \" \" + reference.file.sizeMinified + \"]\";\r\n            e.appendChild(lab);\r\n\r\n            var docs = document.createElement(\"a\");\r\n            docs.className = \"docs\";\r\n            docs.href = data.url;\r\n            e.appendChild(docs);\r\n            this._docs = docs;\r\n\r\n            docs.addEventListener(\"click\", (e) => {\r\n                e.stopPropagation();\r\n            });\r\n        }\r\n\r\n        public setChecked(checked: boolean): void {\r\n            this.element.setAttribute(\"data-checked\", checked ? \"1\" : \"0\");\r\n        }\r\n\r\n        public setDependent(dependent: boolean): void {\r\n            this.element.setAttribute(\"data-dependent\", dependent ? \"1\" : \"0\");\r\n        }\r\n    }\r\n    export class Builder extends Plugin {\r\n\r\n        public symbols: ISymbol[] = null;\r\n        public files: IFile[] = null;\r\n        public modules: IModule[] = null;\r\n\r\n        private _ajax: XMLHttpRequest;\r\n        private _content: HTMLDivElement = null;\r\n\r\n        public static SORT_FILESIZE: SortFunction = (a, b) => {\r\n            return a.file.size - b.file.size;\r\n        };\r\n\r\n        public static SORT_USAGE: SortFunction = (a, b) => {\r\n            return a.usageOrder - b.usageOrder;\r\n        };\r\n\r\n        public static SORT_MODULE: SortFunction = (a, b) => {\r\n            if (a.module != b.module)\r\n                return a.module.fullName.localeCompare(b.module.fullName);\r\n            if (a.name != b.name)\r\n                return a.name.localeCompare(b.name);\r\n            return a.fullName.localeCompare(b.fullName);\r\n        };\r\n\r\n        public static SORT_NAME: SortFunction = (a, b) => {\r\n            return a.name.localeCompare(b.name);\r\n        };\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            var url = \"http://127.0.0.1/eventfive/jsidea-website/build/\" + project + \"/\" + version + \"/\" + project + \".build.json\";\r\n            var req = model.URLRequest.create<string>(url);\r\n            req.addEventListener(\"complete\", () => {\r\n\r\n            });\r\n            req.send();\r\n\r\n            this._ajax = new XMLHttpRequest();\r\n            this._ajax.onreadystatechange = (e) => this.onReadyStateChange(e);\r\n\r\n            var drag = new action.Drag();\r\n\r\n            var project = \"jsidea\";\r\n            var version = \"0.0.1\";\r\n            this.load(\"http://127.0.0.1/eventfive/jsidea-website/build/\" + project + \"/\" + version + \"/\" + project + \".build.json\");\r\n        }\r\n\r\n        public load(url: string): void {\r\n            this._ajax.open(\"GET\", url);\r\n            this._ajax.send(null);\r\n        }\r\n\r\n        private onReadyStateChange(e: ProgressEvent): void {\r\n            if (this._ajax.readyState == 4) {\r\n                if (this._ajax.status == 200) {\r\n                    this.parse(JSON.parse(this._ajax.responseText));\r\n\r\n                    //                    var tar: HTMLElement = null;\r\n                    //                    var el = document.createElement(\"div\");\r\n                    //                    el.style.top = \"0px\";\r\n                    //                    el.style.left = \"0px\";\r\n                    //                    //            el.style.width = \"200px\";\r\n                    //                    //            el.style.height = \"200px\";\r\n                    //                    //            el.style.backgroundColor = \"#FFFF00\";\r\n                    //                    el.style.position = \"fixed\";\r\n                    //                    document.body.appendChild(el);\r\n                    //                    document.addEventListener(\"click\", (e) => {\r\n                    //                        tar = <HTMLElement>e.target;\r\n                    //                    });\r\n                    //                    var trans = new layout.Transform();\r\n                    //                    document.addEventListener(\"mousemove\", (e) => {\r\n                    //                        if (!tar)\r\n                    //                            return;\r\n                    //\r\n                    //                        trans.update(tar);\r\n                    //                        var local = trans.globalToLocal(e.pageX, e.pageY, 0);\r\n                    //                        el.textContent = local.x + \" \" + local.y;\r\n                    //                    });\r\n                }\r\n                else {\r\n                    console.log(this._ajax.statusText);\r\n                }\r\n            }\r\n        }\r\n\r\n        private parse(dat: IData): void {\r\n            var data = dat.typescript;\r\n            this._content = document.createElement(\"div\");\r\n            this._content.id = \"dependency\";\r\n            document.body.appendChild(this._content);\r\n            \r\n            //            var host = ts.createCompilerHost({ noLib: true });\r\n            //            console.log(host);\r\n            \r\n            //get all exports\r\n            this.symbols = data;\r\n            this.files = dat.files;\r\n            this.modules = [];\r\n            \r\n            //            for (var file of dat.files)\r\n            //                file.sizeMinified = text.Text.byteLengthUTF8(file.code);\r\n            \r\n            //create/collect references\r\n            var refs: ISymbol[] = this.symbols;\r\n            \r\n            //resolve names to IReference objects\r\n            var moduleLookup: any = {};\r\n            var modules: IModule[] = this.modules;\r\n            for (var ref of refs) {\r\n                ref.file = this.getFileByName(<any>ref.file);\r\n                for (var i = 0; i < ref.imports.length; ++i)\r\n                    ref.imports[i] = this.getByQualifiedName(<any>ref.imports[i]);\r\n                var path = ref.fullName.split(\".\");\r\n                ref.name = path[path.length - 1];\r\n                ref.module = null;//\r\n                ref.isDependent = false;\r\n                ref.isChecked = false;\r\n                var moduleName = path.slice(0, path.length - 1).join(\".\");\r\n                if (!moduleLookup[moduleName]) {\r\n                    ref.module = { fullName: moduleName, name: path[path.length - 2], symbols: [ref], ui: null };\r\n                    moduleLookup[moduleName] = ref.module;\r\n                    modules.push(ref.module);\r\n                }\r\n                else {\r\n                    ref.module = moduleLookup[moduleName];\r\n                    ref.module.symbols.push(ref);\r\n                }\r\n\r\n                if (!ref.usage)\r\n                    ref.usage = [];\r\n                for (var chi of ref.imports) {\r\n                    if (!chi.usage)\r\n                        chi.usage = [];\r\n                    if (chi.usage.indexOf(ref) === -1)\r\n                        chi.usage.push(ref);\r\n                }\r\n                ref.url = this.getURL(ref);\r\n            }\r\n\r\n            modules.sort((a, b) => {\r\n                return a.name.localeCompare(b.name);\r\n            });\r\n\r\n            //create ui\r\n            for (var mod of modules) {\r\n                mod.symbols.sort(Builder.SORT_NAME);\r\n                mod.ui = this.createModuleUI(mod);\r\n                for (var sym of mod.symbols) {\r\n                    sym.ui = this.createSymbolUI(sym);\r\n                }\r\n            }\r\n            \r\n            //multipath(2/3)\r\n            for (var ref of refs) {\r\n                ref.relations = this.createRelations(ref);\r\n            }\r\n\r\n            this.sort(Builder.SORT_MODULE);\r\n            \r\n            //multipath(3/3)\r\n            var ordered = this.getOrderedSymbols();\r\n            var i = 0;\r\n            for (var ref of ordered) {\r\n                ref.usageOrder = i++;\r\n            }\r\n\r\n            this.sort(Builder.SORT_MODULE);\r\n            \r\n            //            console.log(SourceMapGenerator);\r\n            //            return;\r\n            \r\n            //---------------\r\n            //TEST TYPESCRIPT\r\n            //---------------\r\n            \r\n            //            var filesToCompile = this.files;\r\n            //            var opt: ts.CompilerOptions = {};\r\n            //            opt.declaration = true;\r\n            //            opt.sourceMap = true;\r\n            //            opt.outFile = \"jsidea.js\";\r\n            //            var host = new build.VirtualHost(filesToCompile);\r\n            //            var names = [];\r\n            //            for (var f of this.files)\r\n            //                names.push(f.name);\r\n            //            var program = ts.createProgram(names, opt, host);\r\n            //            var em = program.emit();\r\n            //            console.log(host.results);\r\n\r\n            //            var s = new build.SymbolProcessor();\r\n            //            s.run(this.files);\r\n            //            console.log(\"EXPORTS\", s.exports);\r\n            \r\n            \r\n            var host = new build.FileSystem(this.files);\r\n            //            var filesToCompile = host.match(\"*.ts\");\r\n            //            \r\n            //            var opt: ts.CompilerOptions = {};\r\n            //            opt.declaration = true;\r\n            //            opt.sourceMap = true;\r\n            //            opt.outFile = \"jsidea.js\";\r\n            //            \r\n            //            var names = [];\r\n            //            for (var f of filesToCompile)\r\n            //                names.push(f.name);\r\n            //            \r\n            //            var program = ts.createProgram(names, opt, host);\r\n            //            var em = program.emit();\r\n\r\n            //            console.log(\"MATCH\", host.match(\"*.map\"));\r\n            \r\n            var result = build.Usage.TYPESCRIPT.apply(host.match(\"*.ts\"));\r\n            console.log(\"SYMBOLS\", result.symbols);\r\n            \r\n            \r\n\r\n            //            var options: any = {};\r\n            //            var ot: any = {};\r\n            //            //            ot.inSourceMap = host.results[0].code;\r\n            //            //            ot.outSourceMap = true;\r\n            //            var min = UglifyJS.minify(host.results[1].name, host, ot);\r\n            //            console.log(min);\r\n        }\r\n        private getURL(sym: ISymbol): string {\r\n            var base = \"http://127.0.0.1/eventfive/jsidea-build/bin/\";\r\n            if (sym.kind == 213)\r\n                base += \"interfaces/\";\r\n            else if (sym.kind == 212)\r\n                base += \"classes/\";\r\n            else if (sym.kind == 209)\r\n                base += \"modules/\";\r\n            base += sym.module.fullName.toLowerCase();\r\n            if (sym.kind == 209)//variable declaration\r\n                base += \".html#\" + sym.name.toLowerCase();\r\n            else if (sym.kind == 212 || sym.kind == 213)//class or interface\r\n                base += \".\" + sym.name.toLowerCase() + \".html\";\r\n            return base;\r\n        }\r\n\r\n        private getOrderedSymbols(): ISymbol[] {\r\n            function addAt(ary: any[], data: any, index: number): any[] {\r\n                var head = ary.slice(0, index);\r\n                var tail = ary.slice(index);\r\n                ary.splice(0, ary.length);\r\n                for (var da of head)\r\n                    ary.push(da);\r\n                ary.push(data);\r\n                for (var da of tail)\r\n                    ary.push(da);\r\n                return ary;\r\n            }\r\n\r\n            var symbols = this.symbols;\r\n            var res: ISymbol[] = [];\r\n            for (var ref of symbols) {\r\n                var l = res.length;\r\n                for (var i = 0; i < l; ++i) {\r\n                    //if its used by\r\n                    if (res[i] == ref)\r\n                        continue;\r\n                    if (res[i].relations.indexOf(ref) >= 0) {\r\n                        addAt(res, ref, i);\r\n                        break;\r\n                    }\r\n                }\r\n                if (res.indexOf(ref) === -1)\r\n                    res.push(ref);\r\n            }\r\n            return res;\r\n        }\r\n\r\n        public getFileByName(name: string): IFile {\r\n            for (var file of this.files)\r\n                if (file.name == name)\r\n                    return file;\r\n            return null;\r\n        }\r\n\r\n        private getByQualifiedName(name: string): ISymbol {\r\n            var refs = this.symbols;\r\n            for (var ref of refs)\r\n                if (ref.fullName == name)\r\n                    return ref;\r\n            return null;\r\n        }\r\n\r\n        private createRelations(ref: ISymbol, relations?: ISymbol[]): ISymbol[] {\r\n            relations = relations || [];\r\n            for (var imp of ref.imports) {\r\n                if (relations.indexOf(imp) < 0) {\r\n                    relations.push(imp);\r\n                    //                    if (imp.usage.indexOf(ref) === -1)\r\n                    //                        imp.usage.push(ref);\r\n                    this.createRelations(imp, relations);\r\n                }\r\n            }\r\n            return relations;\r\n        }\r\n\r\n        private createModuleUI(mod: IModule): ModuleUI {\r\n            var ui = new ModuleUI(mod);\r\n            this._content.appendChild(ui.element);\r\n            //            ui.element.addEventListener(\"click\", () => this.onClickElement(ref));\r\n            return ui;\r\n        }\r\n\r\n        private createSymbolUI(ref: ISymbol): SymbolUI {\r\n            var ui = new SymbolUI(ref);\r\n            ref.module.ui.list.appendChild(ui.element);\r\n            ui.element.addEventListener(\"click\", () => this.onClickElement(ref));\r\n            return ui;\r\n        }\r\n\r\n        private onClickElement(ref: ISymbol): void {\r\n            ref.isChecked = !ref.isChecked;\r\n            this.refreshDependency();\r\n        }\r\n\r\n        private refreshDependency(): void {\r\n            //collect checked\r\n            //and reset dependent\r\n            var checked: ISymbol[] = [];\r\n            for (var ref of this.symbols) {\r\n                ref.isDependent = false;\r\n                if (ref.isChecked)\r\n                    checked.push(ref);\r\n            }\r\n            \r\n            //mark dependencies\r\n            for (var ref of checked)\r\n                for (var rel of ref.relations)\r\n                    rel.isDependent = true;\r\n            \r\n            //size\r\n            var size = this.getSize();\r\n            //            console.log(\"SIZE\", text.Text.fileSize(size.bytesMinified));\r\n\r\n            //refresh the ui-elements\r\n            this.refreshUI();\r\n        }\r\n\r\n        private getSize(): { bytes: number, bytesMinified: number } {\r\n            var files: IFile[] = [];\r\n            for (var ref of this.symbols)\r\n                if (ref.isDependent)\r\n                    if (files.indexOf(ref.file) === -1)\r\n                        files.push(ref.file);\r\n            var bytesMinified = 0;\r\n            var bytes = 0;\r\n            for (var file of files) {\r\n                bytes += file.size;\r\n                bytesMinified += file.sizeMinified;\r\n            }\r\n            return { bytes: bytes, bytesMinified: bytesMinified };\r\n        }\r\n\r\n        public sort(f: SortFunction): void {\r\n            this.symbols.sort(f);\r\n            \r\n            //            var display = this._list.style.display;\r\n            //            this._list.style.display = \"none\";\r\n            //            for (var symbol of this.symbols)\r\n            //                this._list.appendChild(symbol.ui.getElement());\r\n            //            this._list.style.display = display;\r\n        }\r\n\r\n        private refreshUI(): void {\r\n            for (var ref of this.symbols) {\r\n                ref.ui.setChecked(ref.isChecked);\r\n                ref.ui.setDependent(ref.isDependent);\r\n            }\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/plugins/Plugin.ts",
      "size": 4210,
      "sizeMinified": 1990,
      "code": "namespace jsidea.plugins {\r\n    export class Plugin extends jsidea.events.EventDispatcher {\r\n        private _active: boolean = false;\r\n        private _autoActive: boolean = false;\r\n        private _autoTick: boolean = false;\r\n        private _frameRate: number = 60;\r\n        private _tickInterval: number = 0;\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            this.autoActive = true;\r\n            this.autoTick = true;\r\n            this.tick();\r\n        }\r\n\r\n        public get active(): boolean {\r\n            return this._active;\r\n        }\r\n\r\n        public set active(value: boolean) {\r\n            if (this._active == value)\r\n                return;\r\n            this._active = value;\r\n        }\r\n\r\n        public get autoActive(): boolean {\r\n            return this._autoActive;\r\n        }\r\n\r\n        public set autoActive(value: boolean) {\r\n            if (this._autoActive == value)\r\n                return;\r\n            this._autoActive = value;\r\n\r\n            if (this._autoActive) {\r\n                this._active = document.visibilityState == \"visible\";\r\n                document.addEventListener(\"visibilitychange\", () => this.onVisibilityChange());\r\n            }\r\n            else\r\n                document.removeEventListener(\"visibilitychange\", null);\r\n        }\r\n\r\n        public get frameRate(): number {\r\n            return this._frameRate;\r\n        }\r\n\r\n        public set frameRate(value: number) {\r\n            value = value < 0 ? 0 : value;\r\n            if (this._frameRate == value)\r\n                return;\r\n            this._frameRate = value;\r\n            this.refreshTickInterval();\r\n        }\r\n\r\n        public tick(): void {\r\n            //            this.broadcast(jsidea.events.Event.TICK);\r\n            var evt = document.createEvent(\"Event\");\r\n            evt.initEvent(\"tick\", true, true);\r\n            document.dispatchEvent(evt);\r\n        }\r\n\r\n        public get autoTick(): boolean {\r\n            return this._autoTick;\r\n        }\r\n\r\n        public set autoTick(value: boolean) {\r\n            if (this._autoTick == value)\r\n                return;\r\n            this._autoTick = value;\r\n            this.refreshTickInterval();\r\n        }\r\n\r\n        private onVisibilityChange(): void {\r\n            this.active = document.visibilityState == \"visible\";\r\n        }\r\n\r\n        private refreshTickInterval(): void {\r\n            clearInterval(this._tickInterval);\r\n            if (this._autoTick && this._frameRate > 0)\r\n                this._tickInterval = <any> setInterval(() => this.tick(), 1000 / this._frameRate);\r\n        }\r\n\r\n        public dispose(): void {\r\n            super.dispose();\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/plugins/Runner.ts",
      "size": 1111,
      "sizeMinified": 480,
      "code": "namespace jsidea.plugins {\r\n    export function Runner(element: HTMLElement): void {\r\n            var plugin: string = element.getAttribute(\"data-plugin\")\r\n            if (!plugin) {\r\n                return;\r\n            }\r\n            var qualifiedClassName = \"jsidea.plugins.\" + plugin;\r\n            var path: string[] = qualifiedClassName.split(\".\");\r\n            var hook: any = window[<any>path[0]];\r\n            for (var i = 1; i < path.length; ++i) {\r\n                if (!hook) {\r\n                    console.warn(\"Plugin '\" + qualifiedClassName + \"' is undefined.\");\r\n                    return;\r\n                }\r\n\r\n                hook = hook[path[i]];\r\n            }\r\n            if (!hook) {\r\n                console.warn(\"Plugin '\" + qualifiedClassName + \"' is undefined.\");\r\n                return;\r\n            }\r\n            var app = new hook();\r\n        }\r\n}\r\n//hook\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n    jsidea.plugins.Runner(document.body);\r\n});"
    },
    {
      "name": "src/jsidea/plugins/Simbox.ts",
      "size": 4140,
      "sizeMinified": 2365,
      "code": "namespace jsidea.plugins {\r\n    interface ISimboxData {\r\n        active: boolean;\r\n        camDynamicHandle: number[];\r\n        camDynamicTip: number[];\r\n        camEgo: number[];\r\n        camStatic: number[];\r\n        path: number[];\r\n        positionHandle: number[];\r\n        positionInjection: number[];\r\n        positionNearest: number[];\r\n        positionNext: number[];\r\n        positionTip: number[];\r\n        progress: number;\r\n        transformNeedle: number[];\r\n    }\r\n    export class Simbox extends Plugin {\r\n        \r\n        //model/data stuff\r\n        private _host: string = \"ws://192.168.1.8:9989\";\r\n        private _socket: WebSocket;\r\n        private _data: ISimboxData = null;\r\n        \r\n        //actual data representation\r\n        private _camera: geom.Matrix3D = new geom.Matrix3D();\r\n        private _tip: geom.Point3D = new geom.Point3D();\r\n        private _handle: geom.Point3D = new geom.Point3D();\r\n\r\n        //dom-elements\r\n        private _crosshair: HTMLElement;\r\n        private _tipElement: HTMLElement;\r\n        private _handleElement: HTMLElement;\r\n        private _cameraSelect: HTMLSelectElement;\r\n        private _tipSelect: HTMLSelectElement;\r\n        private _handleSelect: HTMLSelectElement;\r\n        private _scale: geom.Point3D = new geom.Point3D(2, 2, 2);\r\n\r\n        constructor() {\r\n            super();\r\n\r\n            this._crosshair = document.getElementById(\"crosshair\");\r\n            this._tipElement = document.getElementById(\"tip\");\r\n            this._handleElement = document.getElementById(\"handle\");\r\n            this._cameraSelect = <HTMLSelectElement>document.getElementById(\"camera-select\");\r\n            this._tipSelect = <HTMLSelectElement>document.getElementById(\"tip-select\");\r\n            this._handleSelect = <HTMLSelectElement>document.getElementById(\"handle-select\");\r\n\r\n            this._socket = new WebSocket(this._host);\r\n            this._socket.onopen = () => console.log(\"OPEN\");\r\n            this._socket.onerror = (e) => console.log(\"ERROR\", e);\r\n            this._socket.onmessage = (m) => this.setData(JSON.parse(m.data));\r\n            this._socket.onclose = () => console.log(\"CLOSE\");\r\n\r\n            //TODO: using an array/jquery or something else here\r\n            //or is the event bubbling????\r\n            //            this._cameraSelect.onchange = () => this.refresh();\r\n            //            this._cameraSelect.onkeyup = () => this.refresh();\r\n            //            this._tipSelect.onchange = () => this.refresh();\r\n            //            this._tipSelect.onkeyup = () => this.refresh();\r\n            //            this._handleSelect.onchange = () => this.refresh();\r\n            //            this._handleSelect.onkeyup = () => this.refresh();\r\n            document.documentElement.addEventListener(\"keyup\", () => this.refresh());\r\n            document.documentElement.addEventListener(\"change\", () => this.refresh());\r\n        }\r\n\r\n        private refresh(): void {\r\n            if (!this._data)\r\n                return;\r\n            this.setData(this._data);\r\n        }\r\n\r\n        private setData(data: ISimboxData): void {\r\n            //set for possible reseting\r\n            this._data = data;\r\n            \r\n            //camera matrix\r\n            var camSelect = this._cameraSelect;\r\n            var opt: HTMLOptionElement = camSelect.options[camSelect.selectedIndex];\r\n            var mat: number[] = (<any>data)[opt.value];\r\n            this._camera.setData(mat);\r\n            \r\n            //tip position\r\n            var tipSelect = this._tipSelect;\r\n            var opt: HTMLOptionElement = tipSelect.options[tipSelect.selectedIndex];\r\n            var mat: number[] = (<any>data)[opt.value];\r\n            this._tip.setData(mat);\r\n            this._camera.transform(this._tip, this._tip);\r\n            \r\n            //handle position\r\n            var handleSelect = this._handleSelect;\r\n            var opt: HTMLOptionElement = handleSelect.options[handleSelect.selectedIndex];\r\n            var mat: number[] = (<any>data)[opt.value];\r\n            this._handle.setData(mat);\r\n            this._camera.transform(this._handle, this._handle);\r\n\r\n            //update the dom-elements layout\r\n            this.layout();\r\n        }\r\n\r\n        private layout(): void {\r\n            //the center of the crosshair\r\n            var cenX: number = this._crosshair.offsetWidth * 0.5;\r\n            var cenY: number = this._crosshair.offsetHeight * 0.5;\r\n\r\n            var offX: number = this._tipElement.offsetWidth * -0.5 + cenX;\r\n            var offY: number = this._tipElement.offsetHeight * -0.5 + cenY;\r\n            offX -= this._tip.x * this._scale.x;\r\n            offY -= this._tip.y * this._scale.y;\r\n            this._tipElement.style.transform = \"translate(\" + offX + \"px, \" + offY + \"px)\";\r\n\r\n            offX = this._handleElement.offsetWidth * -0.5 + cenX;\r\n            offY = this._handleElement.offsetHeight * -0.5 + cenY;\r\n            offX -= this._handle.x * this._scale.x;\r\n            offY -= this._handle.y * this._scale.y;\r\n            this._handleElement.style.transform = \"translate(\" + offX + \"px, \" + offY + \"px)\";\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/plugins/Test.ts",
      "size": 9107,
      "sizeMinified": 4341,
      "code": "namespace jsidea.plugins {\r\n    export class Test extends Plugin {\r\n        constructor() {\r\n            super();\r\n\r\n            var vie = document.createElement(\"div\");\r\n            vie.id = \"view\";\r\n            document.body.appendChild(vie);\r\n            var con = document.createElement(\"div\");\r\n            con.id = \"content\";\r\n            vie.appendChild(con);\r\n\r\n            this.testGeometryUtils();\r\n            //            this.testMatrixFit();\r\n            //asfd - de:keyboard :)\r\n        }\r\n\r\n        private testGeometryUtils(): void {\r\n            var con = document.getElementById(\"content\");\r\n            var vie = document.getElementById(\"view\");\r\n\r\n            var max = 17;\r\n            var te = 17;//5;//7;//11 for ie11 testing 5 is scrolling test\r\n            document.body.className = \"test-\" + te;\r\n\r\n            var can = document.createElement(\"canvas\");\r\n            can.id = \"can\";\r\n            can.width = 1920;\r\n            can.height = 1080;\r\n            var ctx = <CanvasRenderingContext2D>can.getContext(\"2d\");\r\n            var teste = `asdfasdf ${can.id}`;\r\n            //            ctx.translate(100, 100);\r\n            //            ctx.scale(2, 2);\r\n            //            ctx.rotate(45);\r\n            //            ctx = can.getContext(\"2d\");\r\n            //            console.log(\"CURRENT TRANSFORM\", ctx.getTransform());\r\n\r\n            var a = document.createElement(\"div\");\r\n            a.id = \"a-cont\";\r\n\r\n            var tes = document.createElement(\"div\");\r\n            tes.id = \"tes-cont\";\r\n            tes.style.fontSize = \"100px\";\r\n            con.appendChild(tes);\r\n\r\n            var b = document.createElement(\"div\");\r\n            b.id = \"b-cont\";\r\n            var c = document.createElement(\"div\");\r\n            c.id = \"c-cont\";\r\n            var d = document.createElement(\"div\");\r\n            d.id = \"d-cont\";\r\n            var xc = document.createElement(\"div\");\r\n            xc.id = \"x-cont\";\r\n\r\n            a.appendChild(b);\r\n            b.appendChild(c);\r\n            c.appendChild(d);\r\n            d.appendChild(xc);\r\n            con.appendChild(a);\r\n            document.body.appendChild(can);\r\n\r\n            document.addEventListener(\"mousemove\", (evt) => {\r\n                var pt = layout.Transform.create(xc).globalToLocal(evt.pageX, evt.pageY, 0, null, layout.BoxModel.BORDER);\r\n                tes.textContent = Math.round(pt.x) + \" \" + Math.round(pt.y);\r\n            });\r\n\r\n            var mode = layout.MoveMode.TRANSFORM;\r\n\r\n            var snap = new layout.Snap();\r\n            snap.grid.element = document.documentElement;\r\n            snap.grid.boxModel = layout.BoxModel.PADDING;\r\n            snap.to.x = 0;//\"100%\";\r\n            snap.to.y = 0;//\"100%\";\r\n            snap.to.boxModel = mode.boxModel;\r\n\r\n            var pos = new layout.Position();\r\n            pos.snap = snap;\r\n\r\n            //drag settings\r\n            pos.move.mode = mode;\r\n            pos.to.boxModel = mode.boxModel;\r\n            var invertX = mode.invertX;\r\n            var invertY = mode.invertY;\r\n\r\n            var target: HTMLElement = null;\r\n            var pivot = new geom.Point3D();\r\n            var box = new geom.Rect2D();\r\n            var transform = layout.Transform.create();\r\n            var size: layout.Box = layout.Box.create();\r\n            var cursor = new geom.Point3D();\r\n            \r\n            //drag begin\r\n            document.addEventListener(\"mousedown\", (evt) => {\r\n                target = <HTMLElement>evt.target;\r\n\r\n                evt.preventDefault();\r\n                evt.stopImmediatePropagation();\r\n\r\n                var mode = pos.move.mode || layout.MoveMode.TRANSFORM;\r\n                target.style.willChange = mode.willChange;\r\n\r\n                cursor.setTo(evt.pageX, evt.pageY, 0);\r\n                transform.update(target);\r\n\r\n                var loc = transform.globalToLocalPoint(cursor, layout.BoxModel.BORDER, pos.to.boxModel);\r\n                box = transform.size.bounds(pos.to.boxModel, null, box);\r\n                pivot.x = invertX ? (box.width - loc.x) : loc.x;\r\n                pivot.y = invertY ? (box.height - loc.y) : loc.y;\r\n\r\n            });\r\n            //drag\r\n            document.addEventListener(\"mousemove\", (evt) => {\r\n                if (!target)\r\n                    return;\r\n\r\n                evt.preventDefault();\r\n                evt.stopImmediatePropagation();\r\n\r\n                cursor.setTo(evt.pageX, evt.pageY, 0);\r\n                size.update(target, window.getComputedStyle(target));\r\n                box = size.bounds(pos.to.boxModel, null, box);\r\n                pos.to.x = invertX ? (box.width - pivot.x) : pivot.x;\r\n                pos.to.y = invertY ? (box.height - pivot.y) : pivot.y;\r\n\r\n                pos.from.x = cursor.x;\r\n                pos.from.y = cursor.y;\r\n                layout.Position.apply(pos, target);\r\n            });\r\n            //drag end\r\n            document.addEventListener(\"mouseup\", (evt) => {\r\n                if (target)\r\n                    target.style.willChange = \"auto\";\r\n                target = null;\r\n\r\n                evt.preventDefault();\r\n                evt.stopImmediatePropagation();\r\n            });\r\n\r\n            //                        document.addEventListener(\"click\",() => this.logChain(xc));\r\n\r\n            var draw = () => {\r\n                var g = display.Graphics.get(ctx);\r\n                g.clear();\r\n                g.bounds(vie);//, layout.BoxModel.PADDING);\r\n                g.bounds(con);\r\n                g.bounds(a);\r\n                g.bounds(b);\r\n                g.bounds(c);\r\n                g.bounds(d);\r\n                g.bounds(xc);//, layout.BoxModel.ATTACHMENT);\r\n                g.bounds(can);\r\n                g.stroke(\"#00FF00\", 4);\r\n            };\r\n            document.addEventListener(\"click\", draw);\r\n\r\n            var setTest = (e: KeyboardEvent) => {\r\n                if (e.keyCode == 37 || e.keyCode == 39) {\r\n                    if (e.keyCode == 37)\r\n                        te--;\r\n                    else\r\n                        te++;\r\n                    if (te > max)\r\n                        te = 0;\r\n                    else if (te < 0)\r\n                        te = max;\r\n                    document.body.className = \"test-\" + te;\r\n                    console.log(\"TEST-\" + te);\r\n                }\r\n            }\r\n            document.addEventListener(\"keyup\", setTest);\r\n        }\r\n\r\n        private testMatrixFit(): void {\r\n            var q = new geom.Quad(\r\n                new geom.Point3D(0, 0, 0),\r\n                new geom.Point3D(200, 50, 0),\r\n                new geom.Point3D(100, 300, 0),\r\n                new geom.Point3D(300, 300, 0));\r\n\r\n            var el = document.createElement(\"div\");\r\n            el.style.backgroundColor = \"#FFFF00\";\r\n            el.style.position = \"absolute\";\r\n            el.style.width = \"150px\";\r\n            el.style.height = \"120px\";\r\n            document.body.appendChild(el);\r\n            var origin = new geom.Point2D(0, 0);\r\n            el.style.transformOrigin = origin.x + \"px \" + origin.y + \"px\";\r\n            var res = geom.MatrixFit.fromQuad(origin, el.offsetWidth, el.offsetHeight, q);\r\n            el.style.transform = res.getCSS3D();\r\n        }\r\n\r\n        private testMutationObserver(): void {\r\n            //           var target = con;\r\n            //             var observer = new MutationObserver(function(mutations) {\r\n            //                mutations.forEach(function(mutation) {\r\n            //                    console.log(\r\n            //                    mutation.type, \r\n            //                        mutation.attributeName, \r\n            //                        mutation.oldValue, \r\n            //                        mutation.target[mutation.attributeName],\r\n            //                        mutation.attributeNamespace,\r\n            //                        mutation.target);\r\n            //                });\r\n            //            });\r\n            //            var config:MutationObserverInit = { attributes: true, childList: true, characterData: true, subtree: true };\r\n            //            observer.observe(target, config);\r\n            //            document.documentElement.addEventListener('DOMAttrModified', function(e) {\r\n            //                if (e.attrName === 'style') {\r\n            //                    console.log('prevValue: ' + e.prevValue, 'newValue: ' + e.newValue);\r\n            //                }\r\n            //            }, false);\r\n        }\r\n\r\n        private drawOffsetChain(ctx: CanvasRenderingContext2D, e: HTMLElement): void {\r\n            while (e && e.parentElement != document.body.parentElement) {\r\n                var sc = layout.StyleNode.create(e);\r\n                display.Graphics.get(ctx).cross(sc.offset.x, sc.offset.y, 20).stroke();\r\n                e = e.parentElement;\r\n            }\r\n        }\r\n\r\n        private logChain(f: HTMLElement): void {\r\n            var node = layout.StyleNode.create(f);\r\n            if (node)\r\n                node = node.first;\r\n            while (node) {\r\n                var ofp = <HTMLElement>node.element.offsetParent;\r\n                var calcedOff = node.offsetParent ? node.offsetParent.element : null;\r\n                //                var calced = geom.Transform.getParentBlock(node);\r\n                //                var calcedPar = calced ? calced.element : null;\r\n                var scaleOff = node.parentScroll ? node.parentScroll.element : null;\r\n                var res = ([\r\n                    text.Text.conc(10, \" \", node.element.id ? node.element.id : node.element.nodeName),\r\n                    //                    text.Text.conc(16, \" \", \"PARENT\", ofp ? (ofp.id ? ofp.id : ofp.nodeName) : \"NONE\"),\r\n                    //                    text.Text.conc(16, \" \", \"PARENT_C\", calcedOff ? (calcedOff.id ? calcedOff.id : calcedOff.nodeName) : \"NONE\"),\r\n                    \r\n                    //                    text.Text.conc(18, \" \", \"SCROLL_C\", scaleOff ? (scaleOff.id ? scaleOff.id : scaleOff.nodeName) : \"NONE\"),\r\n                    //                    text.Text.conc(18, \" \", \"PARENT_B\", calcedPar ? (calcedPar.id ? calcedPar.id : calcedPar.nodeName) : \"NONE\"),\r\n                    \r\n                    //                    text.Text.conc(18, \" \", \"OFFSET\", node.offsetLeft, node.offsetTop),\r\n                    //                    text.Text.conc(18, \" \", \"OFFSET_C\", node.offset.x, node.offset.y),\r\n                    //                    text.Text.conc(18, \" \", \"PRESERVED\", node.isPreserved3d),\r\n                    \r\n                    //                    text.Text.conc(12, \" \", \"DISPLAY\", node.style.display),\r\n                    text.Text.conc(12, \" \", \"FORCED_2D\", node.isForced2D),\r\n                    //                    text.Text.conc(18, \" \", \"SCROLL\", node.element.scrollLeft, node.element.scrollTop),\r\n                    //                    text.Text.conc(18, \" \", \"TRANSFORMED\", node.isTransformed, node.style.perspective),\r\n                    //                    text.Text.conc(18, \" \", \"TRANSFORMED\", node.style.transform),\r\n                    //                    text.Text.conc(18, \" \", \"PRESERVED\", node.isPreserved3dOrPerspective),//, node.style.transformStyle),\r\n                    \r\n                    //                    text.Text.conc(18, \" \", \"MARGIN\", node.style.marginLeft, node.style.marginTop),\r\n                    //                    text.Text.conc(18, \" \", \"BORDER\", node.style.borderLeftWidth, node.style.borderTopWidth),\r\n                    //                    text.Text.conc(18, \" \", \"PADDING\", node.style.paddingLeft, node.style.paddingTop),\r\n                    //                    text.Text.conc(18, \" \", \"OVERFLOW\", node.style.overflow),\r\n                    //                    text.Text.conc(18, \" \", \"POSITION\", node.style.position, node.isSticked)\r\n                ]).join(\" \");\r\n                console.log(res);\r\n                node = node.child;\r\n            }\r\n        }\r\n\r\n        //        private testObserver(): void {\r\n        //            var d = document.createElement(\"div\");\r\n        //            d.textContent = \"A\";\r\n        //            document.body.appendChild(d);\r\n        //            var o = d[0];\r\n        //            Object.observe(o, function(a): void {\r\n        //                console.log(a);\r\n        //            });\r\n        //            o.style.width = \"200px\";\r\n        //            o.style.height = \"200px\";\r\n        //            o.style.backgroundColor = \"#FF00FF\";\r\n        //            //ARRGHHH funzt nit\r\n        //        }\r\n\r\n        private testEventDispatcher(): void {\r\n            var d = new jsidea.events.EventDispatcher();\r\n            //            d.bind(\"click.setup\",(e: jsidea.events.IEvent) => console.log(e.eventType));\r\n            //            d.trigger(\".setup\");\r\n        }\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/system/Browser.ts",
      "size": 4319,
      "sizeMinified": 1748,
      "code": "namespace jsidea.system {\r\n    export class Browser {\r\n        //browsers\r\n        public static isOpera = /opr\\//i.test(navigator.userAgent) || /opera/i.test(navigator.userAgent);\r\n        public static isChrome = !Browser.isOpera && /chrome/i.test(navigator.userAgent);\r\n        public static isFirefox = /firefox/i.test(navigator.userAgent);\r\n        public static isSafari = !Browser.isChrome && !Browser.isFirefox && !Browser.isOpera && /safari/i.test(navigator.userAgent);\r\n        public static isInternetExplorer = (navigator.userAgent.indexOf(\"MSIE\") != -1) || !!navigator.userAgent.match(/Trident.*rv[ :]*11\\./);\r\n        public static isEdge = /edge\\//i.test(navigator.userAgent);\r\n        public static isYandex = /yandex/i.test(navigator.userAgent);\r\n        public static name: string = (() => {\r\n            if (Browser.isOpera)\r\n                return \"Opera\";\r\n            if (Browser.isChrome)\r\n                return \"Chrome\";\r\n            if (Browser.isFirefox)\r\n                return \"Firefox\";\r\n            if (Browser.isSafari)\r\n                return \"Safari\";\r\n            if (Browser.isInternetExplorer)\r\n                return \"Internet Explorer\";\r\n            if (Browser.isYandex)\r\n                return \"Yandex\";\r\n            return \"\";\r\n        })();\r\n        //source: http://www.javascripter.net/faq/browsern.htm\r\n        public static version: string = (() => {\r\n            var nVer = navigator.appVersion;\r\n            var nAgt = navigator.userAgent.toLowerCase();\r\n            var fullVersion = '' + parseFloat(navigator.appVersion);\r\n            var nameOffset: number, verOffset: number, ix: number;\r\n            if ((verOffset = nAgt.indexOf(\"opr/\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 4);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"opera\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 6);\r\n                if ((verOffset = nAgt.indexOf(\"version\")) != -1)\r\n                    fullVersion = nAgt.substring(verOffset + 8);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"msie\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 5);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"edge/\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 5);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"; rv:\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 5);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"chrome\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 7);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"safari\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 7);\r\n                if ((verOffset = nAgt.indexOf(\"version\")) != -1)\r\n                    fullVersion = nAgt.substring(verOffset + 8);\r\n            }\r\n            else if ((verOffset = nAgt.indexOf(\"firefox\")) != -1) {\r\n                fullVersion = nAgt.substring(verOffset + 8);\r\n            }\r\n            else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) <\r\n                (verOffset = nAgt.lastIndexOf('/'))) {\r\n                fullVersion = nAgt.substring(verOffset + 1);\r\n            }\r\n            if ((ix = fullVersion.indexOf(\")\")) != -1)\r\n                fullVersion = fullVersion.substring(0, ix);\r\n            if ((ix = fullVersion.indexOf(\";\")) != -1)\r\n                fullVersion = fullVersion.substring(0, ix);\r\n            if ((ix = fullVersion.indexOf(\" \")) != -1)\r\n                fullVersion = fullVersion.substring(0, ix);\r\n            if (isNaN(parseInt('' + fullVersion, 10)))\r\n                fullVersion = '' + parseFloat(navigator.appVersion);\r\n            if (isNaN(parseInt('' + fullVersion, 10)))\r\n                fullVersion = \"\";\r\n            return fullVersion;\r\n        })();\r\n        public static major: number = parseInt(Browser.version);\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/system/Engine.ts",
      "size": 1329,
      "sizeMinified": 673,
      "code": "namespace jsidea.system {\r\n    export class Engine {\r\n        //engines\r\n        public static isWebKit = !Browser.isInternetExplorer && !Browser.isEdge && /webkit/i.test(navigator.userAgent);\r\n        public static isBlink = Engine.isWebKit && ((Browser.isChrome && Browser.major >= 28) || (Browser.isOpera && Browser.major >= 15) || Browser.isYandex);\r\n        public static isTrident = /trident/i.test(navigator.userAgent);\r\n        public static isGecko = !Browser.isInternetExplorer && !Engine.isWebKit && /gecko/i.test(navigator.userAgent);\r\n        public static isEdgeHTML = Browser.isEdge && Browser.major >= 12;\r\n        public static name: string = (() => {\r\n            if (Engine.isBlink)\r\n                return \"WebKit/Blink\";\r\n            if (Engine.isWebKit)\r\n                return \"WebKit\";\r\n            if (Engine.isTrident)\r\n                return \"Trident\";\r\n            if (Engine.isGecko)\r\n                return \"Gecko\";\r\n            return \"\";\r\n        })();\r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/system/System.ts",
      "size": 1360,
      "sizeMinified": 533,
      "code": "namespace jsidea.system {\r\n    export class System {\r\n        //operating systems\r\n        public static isWindows = /win/i.test(navigator.appVersion);\r\n        public static isMac = /mac/i.test(navigator.appVersion);\r\n        public static isUnix = /x11/i.test(navigator.appVersion);\r\n        public static isLinux = /linux/i.test(navigator.appVersion);\r\n        public static name: string = (() => {\r\n            if (System.isWindows)\r\n                return \"Windows\";\r\n            if (System.isMac)\r\n                return \"Mac OS X\";\r\n            if (System.isUnix)\r\n                return \"Unix\";\r\n            if (System.isLinux)\r\n                return \"Linux\";\r\n            return \"\";\r\n        })();\r\n        public static version: string = (() => {\r\n            if (System.isWindows)\r\n                return \"7\";\r\n            if (System.isMac)\r\n                return \"Yosemite\";\r\n            if (System.isUnix)\r\n                return \"Unix\";\r\n            if (System.isLinux)\r\n                return \"Linux\";\r\n            return \"\";\r\n        })();        \r\n    }\r\n}"
    },
    {
      "name": "src/jsidea/text/Text.ts",
      "size": 2676,
      "sizeMinified": 1040,
      "code": "namespace jsidea.text {\r\n    export class Text {\r\n        public static fillHead(text: string, length: number, char: string = \" \"): string {\r\n            if (text.length >= length)\r\n                return text;\r\n            while (text.length < length)\r\n                text = char + text;\r\n            return text;\r\n        }\r\n\r\n        public static fill(text: string, length: number, char: string = \" \"): string {\r\n            if (text.length >= length)\r\n                return text;\r\n            while (text.length < length)\r\n                text += char;\r\n            return text;\r\n        }\r\n\r\n        public static conc(length: number, char: string = \" \", ...args: any[]): string {\r\n\r\n            return this.fill(args.join(\" \"), length, char);\r\n        }\r\n\r\n        public static color(hexColor: number): string {\r\n            console.log(Math.round(hexColor).toString(16));\r\n            return \"#\" + this.fill(Math.round(hexColor).toString(16), 6, \"0\");\r\n        }\r\n\r\n        //SOURCE: http://stackoverflow.com/questions/5515869/string-length-in-bytes-in-javascript\r\n        public static byteLengthUTF8(str: string): number {\r\n            // returns the byte length of an utf8 string\r\n            var s = str.length;\r\n            for (var i = str.length - 1; i >= 0; i--) {\r\n                var code = str.charCodeAt(i);\r\n                if (code > 0x7f && code <= 0x7ff)\r\n                    s++;\r\n                else if (code > 0x7ff && code <= 0xffff)\r\n                    s += 2;\r\n                if (code >= 0xDC00 && code <= 0xDFFF)\r\n                    i--; //trail surrogate\r\n            }\r\n            return s;\r\n        }\r\n\r\n        public static fileSize(bytes: number, roundMB: Boolean = false): String {\r\n            var mb: number = math.Number.precision(bytes * math.Number.BYTE_TO_MB, 100);\r\n            if (mb > 1000)\r\n                return math.Number.precision(bytes * math.Number.BYTE_TO_GIGABYTE, 100) + \" GB\";\r\n            else if (mb < 1)\r\n                return Math.round(bytes * math.Number.BYTE_TO_KILOBYTE) + \" kB\";\r\n            if (roundMB)\r\n                return Math.round(mb) + \" MB\";\r\n            return mb + \" MB\";\r\n        }\r\n    }\r\n}"
    }
  ]
}